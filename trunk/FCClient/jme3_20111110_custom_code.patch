Index: .classpath
===================================================================
--- .classpath	(revision 0)
+++ .classpath	(revision 0)
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src/terrain"/>
+	<classpathentry kind="src" path="test-data"/>
+	<classpathentry kind="src" path="src/bullet"/>
+	<classpathentry kind="src" path="src/bullet-common"/>
+	<classpathentry kind="src" path="src/android"/>
+	<classpathentry kind="src" path="src/networking"/>
+	<classpathentry kind="src" path="src/blender"/>
+	<classpathentry kind="src" path="src/niftygui"/>
+	<classpathentry kind="src" path="src/core"/>
+	<classpathentry kind="src" path="src/core-data"/>
+	<classpathentry kind="src" path="src/lwjgl"/>
+	<classpathentry kind="src" path="src/desktop"/>
+	<classpathentry kind="src" path="src/ogre"/>
+	<classpathentry kind="src" path="src/core-plugins"/>
+	<classpathentry kind="src" path="src/jogg"/>
+	<classpathentry kind="src" path="src/swingGui"/>
+	<classpathentry kind="src" path="src/xml"/>
+	<classpathentry kind="src" path="src/tools"/>
+	<classpathentry kind="src" path="src/test"/>
+	<classpathentry kind="lib" path="lib/jbullet/asm-all-3.1.jar"/>
+	<classpathentry kind="lib" path="lib/jbullet/jbullet.jar"/>
+	<classpathentry kind="lib" path="lib/jbullet/stack-alloc.jar"/>
+	<classpathentry kind="lib" path="lib/jbullet/vecmath.jar"/>
+	<classpathentry kind="lib" path="lib/jogg/j-ogg-oggd.jar"/>
+	<classpathentry kind="lib" path="lib/jogg/j-ogg-vorbisd.jar"/>
+	<classpathentry kind="lib" path="lib/swing-layout/swing-layout-1.0.4.jar"/>
+	<classpathentry kind="lib" path="lib/swingext/swing-layout-1.0.3.jar"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="lib/lwjgl/jinput.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/jME3-lwjgl-natives.jar"/>
+	<classpathentry kind="lib" path="lib/noise/noise-0.0.1-SNAPSHOT.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/eventbus.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-default-controls-javadoc.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-default-controls.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-examples-javadoc.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-examples.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-javadoc.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty-style-black.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/nifty.jar"/>
+	<classpathentry kind="lib" path="lib/niftygui/xmlpull-xpp3.jar"/>
+	<classpathentry kind="lib" path="lib/bullet/jME3-bullet-natives.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl_util.jar"/>
+	<classpathentry kind="lib" path="lib/lwjgl/lwjgl-debug.jar"/>
+	<classpathentry kind="lib" path="lib/android/android.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: .project
===================================================================
--- .project	(revision 0)
+++ .project	(revision 0)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>jme3</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: bullet-api-diff.xml
===================================================================
--- bullet-api-diff.xml	(revision 0)
+++ bullet-api-diff.xml	(revision 0)
@@ -0,0 +1,280 @@
+<?xml version="1.0" encoding="utf-8" ?>
+
+<!DOCTYPE differences SYSTEM "http://depfind.sourceforge.net/dtd/differences.dtd">
+
+<differences>
+    <name>jMonkeyEngine3 Bullet Physics API Comparison</name>
+    <old>Java Version</old>
+    <new>Native Version</new>
+    <removed-classes>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$2" extends="com.bulletphysics.collision.broadphase.OverlapFilterCallback" implements="">com.jme3.bullet.PhysicsSpace$2</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$3" extends="com.bulletphysics.dynamics.InternalTickCallback" implements="">com.jme3.bullet.PhysicsSpace$3</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$4" extends="com.bulletphysics.dynamics.InternalTickCallback" implements="">com.jme3.bullet.PhysicsSpace$4</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$5" extends="com.bulletphysics.ContactAddedCallback" implements="">com.jme3.bullet.PhysicsSpace$5</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$6" extends="com.bulletphysics.ContactProcessedCallback" implements="">com.jme3.bullet.PhysicsSpace$6</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$7" extends="com.bulletphysics.ContactDestroyedCallback" implements="">com.jme3.bullet.PhysicsSpace$7</name>
+        <name visibility="package" super="yes" synthetic="yes" name="com.jme3.bullet.PhysicsSpace$8" extends="java.lang.Object" implements="">com.jme3.bullet.PhysicsSpace$8</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$InternalRayListener" extends="com.bulletphysics.collision.dispatch.CollisionWorld$RayResultCallback" implements="">com.jme3.bullet.PhysicsSpace$InternalRayListener</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.PhysicsSpace$InternalSweepListener" extends="com.bulletphysics.collision.dispatch.CollisionWorld$ConvexResultCallback" implements="">com.jme3.bullet.PhysicsSpace$InternalSweepListener</name>
+        <name visibility="package" super="yes" name="com.jme3.bullet.util.BufferedTriangleCallback" extends="com.bulletphysics.collision.shapes.TriangleCallback" implements="">com.jme3.bullet.util.BufferedTriangleCallback</name>
+        <name visibility="public" super="yes" name="com.jme3.bullet.util.Converter" extends="java.lang.Object" implements="">com.jme3.bullet.util.Converter</name>
+    </removed-classes>
+    <modified-classes>
+        <class>
+            <name>com.jme3.bullet.PhysicsSpace</name>
+            <removed-fields>
+                <declaration visibility="private" type="com.bulletphysics.collision.broadphase.BroadphaseInterface" name="broadphase" signature="broadphase" full-signature="com.jme3.bullet.PhysicsSpace.broadphase">private com.bulletphysics.collision.broadphase.BroadphaseInterface broadphase</declaration>
+                <declaration visibility="private" type="com.bulletphysics.collision.dispatch.DefaultCollisionConfiguration" name="collisionConfiguration" signature="collisionConfiguration" full-signature="com.jme3.bullet.PhysicsSpace.collisionConfiguration">private com.bulletphysics.collision.dispatch.DefaultCollisionConfiguration collisionConfiguration</declaration>
+                <declaration visibility="private" type="com.bulletphysics.collision.dispatch.CollisionDispatcher" name="dispatcher" signature="dispatcher" full-signature="com.jme3.bullet.PhysicsSpace.dispatcher">private com.bulletphysics.collision.dispatch.CollisionDispatcher dispatcher</declaration>
+                <declaration visibility="private" type="com.bulletphysics.dynamics.DiscreteDynamicsWorld" name="dynamicsWorld" signature="dynamicsWorld" full-signature="com.jme3.bullet.PhysicsSpace.dynamicsWorld">private com.bulletphysics.dynamics.DiscreteDynamicsWorld dynamicsWorld</declaration>
+                <declaration visibility="private" type="javax.vecmath.Vector3f" name="rayVec1" signature="rayVec1" full-signature="com.jme3.bullet.PhysicsSpace.rayVec1">private javax.vecmath.Vector3f rayVec1</declaration>
+                <declaration visibility="private" type="javax.vecmath.Vector3f" name="rayVec2" signature="rayVec2" full-signature="com.jme3.bullet.PhysicsSpace.rayVec2">private javax.vecmath.Vector3f rayVec2</declaration>
+                <declaration visibility="private" type="com.bulletphysics.dynamics.constraintsolver.ConstraintSolver" name="solver" signature="solver" full-signature="com.jme3.bullet.PhysicsSpace.solver">private com.bulletphysics.dynamics.constraintsolver.ConstraintSolver solver</declaration>
+                <declaration visibility="private" type="com.bulletphysics.linearmath.Transform" name="sweepTrans1" signature="sweepTrans1" full-signature="com.jme3.bullet.PhysicsSpace.sweepTrans1">private com.bulletphysics.linearmath.Transform sweepTrans1</declaration>
+                <declaration visibility="private" type="com.bulletphysics.linearmath.Transform" name="sweepTrans2" signature="sweepTrans2" full-signature="com.jme3.bullet.PhysicsSpace.sweepTrans2">private com.bulletphysics.linearmath.Transform sweepTrans2</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="package" static="yes" synthetic="yes" return-type="java.util.Map" signature="access$000(com.jme3.bullet.PhysicsSpace)" full-signature="com.jme3.bullet.PhysicsSpace.access$000(com.jme3.bullet.PhysicsSpace)" throws="">static java.util.Map access$000(com.jme3.bullet.PhysicsSpace)</declaration>
+                <declaration visibility="package" static="yes" synthetic="yes" return-type="java.util.concurrent.ConcurrentLinkedQueue" signature="access$100(com.jme3.bullet.PhysicsSpace)" full-signature="com.jme3.bullet.PhysicsSpace.access$100(com.jme3.bullet.PhysicsSpace)" throws="">static java.util.concurrent.ConcurrentLinkedQueue access$100(com.jme3.bullet.PhysicsSpace)</declaration>
+                <declaration visibility="package" static="yes" synthetic="yes" return-type="java.util.concurrent.ConcurrentLinkedQueue" signature="access$200(com.jme3.bullet.PhysicsSpace)" full-signature="com.jme3.bullet.PhysicsSpace.access$200(com.jme3.bullet.PhysicsSpace)" throws="">static java.util.concurrent.ConcurrentLinkedQueue access$200(com.jme3.bullet.PhysicsSpace)</declaration>
+                <declaration visibility="package" static="yes" synthetic="yes" return-type="com.jme3.bullet.collision.PhysicsCollisionEventFactory" signature="access$300(com.jme3.bullet.PhysicsSpace)" full-signature="com.jme3.bullet.PhysicsSpace.access$300(com.jme3.bullet.PhysicsSpace)" throws="">static com.jme3.bullet.collision.PhysicsCollisionEventFactory access$300(com.jme3.bullet.PhysicsSpace)</declaration>
+                <declaration visibility="package" static="yes" synthetic="yes" return-type="java.util.List" signature="access$400(com.jme3.bullet.PhysicsSpace)" full-signature="com.jme3.bullet.PhysicsSpace.access$400(com.jme3.bullet.PhysicsSpace)" throws="">static java.util.List access$400(com.jme3.bullet.PhysicsSpace)</declaration>
+                <declaration visibility="public" return-type="void" signature="applyGravity()" full-signature="com.jme3.bullet.PhysicsSpace.applyGravity()" throws="">public void applyGravity()</declaration>
+                <declaration visibility="public" return-type="void" signature="clearForces()" full-signature="com.jme3.bullet.PhysicsSpace.clearForces()" throws="">public void clearForces()</declaration>
+                <declaration visibility="public" return-type="com.bulletphysics.dynamics.DynamicsWorld" signature="getDynamicsWorld()" full-signature="com.jme3.bullet.PhysicsSpace.getDynamicsWorld()" throws="">public com.bulletphysics.dynamics.DynamicsWorld getDynamicsWorld()</declaration>
+                <declaration visibility="private" return-type="void" signature="setContactCallbacks()" full-signature="com.jme3.bullet.PhysicsSpace.setContactCallbacks()" throws="">private void setContactCallbacks()</declaration>
+                <declaration visibility="private" return-type="void" signature="setOverlapFilterCallback()" full-signature="com.jme3.bullet.PhysicsSpace.setOverlapFilterCallback()" throws="">private void setOverlapFilterCallback()</declaration>
+                <declaration visibility="private" return-type="void" signature="setTickCallback()" full-signature="com.jme3.bullet.PhysicsSpace.setTickCallback()" throws="">private void setTickCallback()</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.PhysicsCollisionEvent</name>
+            <removed-fields>
+                <declaration visibility="private" type="com.bulletphysics.collision.narrowphase.ManifoldPoint" name="cp" signature="cp" full-signature="com.jme3.bullet.collision.PhysicsCollisionEvent.cp">private com.bulletphysics.collision.narrowphase.ManifoldPoint cp</declaration>
+            </removed-fields>
+            <removed-constructors>
+                <declaration visibility="public" signature="PhysicsCollisionEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" full-signature="com.jme3.bullet.collision.PhysicsCollisionEvent.PhysicsCollisionEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" throws="">public PhysicsCollisionEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)</declaration>
+            </removed-constructors>
+            <removed-methods>
+                <declaration visibility="public" return-type="void" signature="refactor(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" full-signature="com.jme3.bullet.collision.PhysicsCollisionEvent.refactor(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" throws="">public void refactor(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.PhysicsCollisionEventFactory</name>
+            <removed-methods>
+                <declaration visibility="public" return-type="com.jme3.bullet.collision.PhysicsCollisionEvent" signature="getEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" full-signature="com.jme3.bullet.collision.PhysicsCollisionEventFactory.getEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)" throws="">public com.jme3.bullet.collision.PhysicsCollisionEvent getEvent(int, com.jme3.bullet.collision.PhysicsCollisionObject, com.jme3.bullet.collision.PhysicsCollisionObject, com.bulletphysics.collision.narrowphase.ManifoldPoint)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.shapes.CollisionShape</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.collision.shapes.CollisionShape" name="cShape" signature="cShape" full-signature="com.jme3.bullet.collision.shapes.CollisionShape.cShape">protected com.bulletphysics.collision.shapes.CollisionShape cShape</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="void" signature="calculateLocalInertia(float, javax.vecmath.Vector3f)" full-signature="com.jme3.bullet.collision.shapes.CollisionShape.calculateLocalInertia(float, javax.vecmath.Vector3f)" throws="">public void calculateLocalInertia(float, javax.vecmath.Vector3f)</declaration>
+                <declaration visibility="public" return-type="com.bulletphysics.collision.shapes.CollisionShape" signature="getCShape()" full-signature="com.jme3.bullet.collision.shapes.CollisionShape.getCShape()" throws="">public com.bulletphysics.collision.shapes.CollisionShape getCShape()</declaration>
+                <declaration visibility="public" return-type="void" signature="setCShape(com.bulletphysics.collision.shapes.CollisionShape)" full-signature="com.jme3.bullet.collision.shapes.CollisionShape.setCShape(com.bulletphysics.collision.shapes.CollisionShape)" throws="">public void setCShape(com.bulletphysics.collision.shapes.CollisionShape)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.shapes.GImpactCollisionShape</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.collision.shapes.IndexedMesh" name="bulletMesh" signature="bulletMesh" full-signature="com.jme3.bullet.collision.shapes.GImpactCollisionShape.bulletMesh">protected com.bulletphysics.collision.shapes.IndexedMesh bulletMesh</declaration>
+                <declaration visibility="protected" type="com.jme3.math.Vector3f" name="worldScale" signature="worldScale" full-signature="com.jme3.bullet.collision.shapes.GImpactCollisionShape.worldScale">protected com.jme3.math.Vector3f worldScale</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="private" return-type="void" signature="createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)" full-signature="com.jme3.bullet.collision.shapes.GImpactCollisionShape.createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)" throws="">private void createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)</declaration>
+                <declaration visibility="public" return-type="com.jme3.scene.Mesh" signature="createJmeMesh()" full-signature="com.jme3.bullet.collision.shapes.GImpactCollisionShape.createJmeMesh()" throws="">public com.jme3.scene.Mesh createJmeMesh()</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.shapes.HullCollisionShape</name>
+            <removed-methods>
+                <declaration visibility="protected" return-type="void" signature="createShape(float[])" full-signature="com.jme3.bullet.collision.shapes.HullCollisionShape.createShape(float[])" throws="">protected void createShape(float[])</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.collision.shapes.MeshCollisionShape</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.collision.shapes.IndexedMesh" name="bulletMesh" signature="bulletMesh" full-signature="com.jme3.bullet.collision.shapes.MeshCollisionShape.bulletMesh">protected com.bulletphysics.collision.shapes.IndexedMesh bulletMesh</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="private" return-type="void" signature="createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)" full-signature="com.jme3.bullet.collision.shapes.MeshCollisionShape.createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)" throws="">private void createCollisionMesh(com.jme3.scene.Mesh, com.jme3.math.Vector3f)</declaration>
+                <declaration visibility="public" return-type="com.jme3.scene.Mesh" signature="createJmeMesh()" full-signature="com.jme3.bullet.collision.shapes.MeshCollisionShape.createJmeMesh()" throws="">public com.jme3.scene.Mesh createJmeMesh()</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.joints.PhysicsJoint</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.constraintsolver.TypedConstraint" name="constraint" signature="constraint" full-signature="com.jme3.bullet.joints.PhysicsJoint.constraint">protected com.bulletphysics.dynamics.constraintsolver.TypedConstraint constraint</declaration>
+            </removed-fields>
+            <modified-methods>
+                <feature>
+                    <name>com.jme3.bullet.joints.PhysicsJoint.getObjectId()</name>
+                    <modified-declaration>
+                        <old-declaration visibility="public" return-type="com.bulletphysics.dynamics.constraintsolver.TypedConstraint" signature="getObjectId()" full-signature="com.jme3.bullet.joints.PhysicsJoint.getObjectId()" throws="">public com.bulletphysics.dynamics.constraintsolver.TypedConstraint getObjectId()</old-declaration>
+                        <new-declaration visibility="public" return-type="long" signature="getObjectId()" full-signature="com.jme3.bullet.joints.PhysicsJoint.getObjectId()" throws="">public long getObjectId()</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.joints.motors.RotationalLimitMotor</name>
+            <removed-fields>
+                <declaration visibility="private" type="com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor" name="motor" signature="motor" full-signature="com.jme3.bullet.joints.motors.RotationalLimitMotor.motor">private com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor motor</declaration>
+            </removed-fields>
+            <removed-constructors>
+                <declaration visibility="public" signature="RotationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor)" full-signature="com.jme3.bullet.joints.motors.RotationalLimitMotor.RotationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor)" throws="">public RotationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor)</declaration>
+            </removed-constructors>
+            <modified-methods>
+                <feature>
+                    <name>com.jme3.bullet.joints.motors.RotationalLimitMotor.getMotor()</name>
+                    <modified-declaration>
+                        <old-declaration visibility="public" return-type="com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor" signature="getMotor()" full-signature="com.jme3.bullet.joints.motors.RotationalLimitMotor.getMotor()" throws="">public com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor getMotor()</old-declaration>
+                        <new-declaration visibility="public" return-type="long" signature="getMotor()" full-signature="com.jme3.bullet.joints.motors.RotationalLimitMotor.getMotor()" throws="">public long getMotor()</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.joints.motors.TranslationalLimitMotor</name>
+            <removed-fields>
+                <declaration visibility="private" type="com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor" name="motor" signature="motor" full-signature="com.jme3.bullet.joints.motors.TranslationalLimitMotor.motor">private com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor motor</declaration>
+            </removed-fields>
+            <removed-constructors>
+                <declaration visibility="public" signature="TranslationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor)" full-signature="com.jme3.bullet.joints.motors.TranslationalLimitMotor.TranslationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor)" throws="">public TranslationalLimitMotor(com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor)</declaration>
+            </removed-constructors>
+            <modified-methods>
+                <feature>
+                    <name>com.jme3.bullet.joints.motors.TranslationalLimitMotor.getMotor()</name>
+                    <modified-declaration>
+                        <old-declaration visibility="public" return-type="com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor" signature="getMotor()" full-signature="com.jme3.bullet.joints.motors.TranslationalLimitMotor.getMotor()" throws="">public com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor getMotor()</old-declaration>
+                        <new-declaration visibility="public" return-type="long" signature="getMotor()" full-signature="com.jme3.bullet.joints.motors.TranslationalLimitMotor.getMotor()" throws="">public long getMotor()</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.PhysicsCharacter</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.character.KinematicCharacterController" name="character" signature="character" full-signature="com.jme3.bullet.objects.PhysicsCharacter.character">protected com.bulletphysics.dynamics.character.KinematicCharacterController character</declaration>
+                <declaration visibility="protected" type="com.bulletphysics.collision.dispatch.PairCachingGhostObject" name="gObject" signature="gObject" full-signature="com.jme3.bullet.objects.PhysicsCharacter.gObject">protected com.bulletphysics.collision.dispatch.PairCachingGhostObject gObject</declaration>
+                <declaration visibility="private" type="com.jme3.math.Transform" name="physicsLocation" signature="physicsLocation" full-signature="com.jme3.bullet.objects.PhysicsCharacter.physicsLocation">private com.jme3.math.Transform physicsLocation</declaration>
+                <declaration visibility="private" type="com.bulletphysics.linearmath.Transform" name="tempTrans" signature="tempTrans" full-signature="com.jme3.bullet.objects.PhysicsCharacter.tempTrans">private com.bulletphysics.linearmath.Transform tempTrans</declaration>
+                <declaration visibility="private" type="javax.vecmath.Vector3f" name="tempVec" signature="tempVec" full-signature="com.jme3.bullet.objects.PhysicsCharacter.tempVec">private javax.vecmath.Vector3f tempVec</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="com.bulletphysics.collision.dispatch.PairCachingGhostObject" signature="getObjectId()" full-signature="com.jme3.bullet.objects.PhysicsCharacter.getObjectId()" throws="">public com.bulletphysics.collision.dispatch.PairCachingGhostObject getObjectId()</declaration>
+            </removed-methods>
+            <modified-methods>
+                <feature>
+                    <name>com.jme3.bullet.objects.PhysicsCharacter.getControllerId()</name>
+                    <modified-declaration>
+                        <old-declaration visibility="public" return-type="com.bulletphysics.dynamics.character.KinematicCharacterController" signature="getControllerId()" full-signature="com.jme3.bullet.objects.PhysicsCharacter.getControllerId()" throws="">public com.bulletphysics.dynamics.character.KinematicCharacterController getControllerId()</old-declaration>
+                        <new-declaration visibility="public" return-type="long" signature="getControllerId()" full-signature="com.jme3.bullet.objects.PhysicsCharacter.getControllerId()" throws="">public long getControllerId()</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.PhysicsGhostObject</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.collision.dispatch.PairCachingGhostObject" name="gObject" signature="gObject" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.gObject">protected com.bulletphysics.collision.dispatch.PairCachingGhostObject gObject</declaration>
+                <declaration visibility="private" type="com.jme3.math.Transform" name="physicsLocation" signature="physicsLocation" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.physicsLocation">private com.jme3.math.Transform physicsLocation</declaration>
+                <declaration visibility="protected" type="javax.vecmath.Quat4f" name="tempRot" signature="tempRot" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.tempRot">protected javax.vecmath.Quat4f tempRot</declaration>
+                <declaration visibility="protected" type="com.bulletphysics.linearmath.Transform" name="tempTrans" signature="tempTrans" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.tempTrans">protected com.bulletphysics.linearmath.Transform tempTrans</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="com.bulletphysics.collision.dispatch.PairCachingGhostObject" signature="getObjectId()" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.getObjectId()" throws="">public com.bulletphysics.collision.dispatch.PairCachingGhostObject getObjectId()</declaration>
+                <declaration visibility="public" return-type="com.jme3.math.Transform" signature="getPhysicsTransform()" full-signature="com.jme3.bullet.objects.PhysicsGhostObject.getPhysicsTransform()" throws="">public com.jme3.math.Transform getPhysicsTransform()</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.PhysicsRigidBody</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.RigidBodyConstructionInfo" name="constructionInfo" signature="constructionInfo" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.constructionInfo">protected com.bulletphysics.dynamics.RigidBodyConstructionInfo constructionInfo</declaration>
+                <declaration visibility="protected" type="javax.vecmath.Vector3f" name="localInertia" signature="localInertia" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.localInertia">protected javax.vecmath.Vector3f localInertia</declaration>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.RigidBody" name="rBody" signature="rBody" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.rBody">protected com.bulletphysics.dynamics.RigidBody rBody</declaration>
+                <declaration visibility="protected" type="javax.vecmath.Matrix3f" name="tempMatrix" signature="tempMatrix" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.tempMatrix">protected javax.vecmath.Matrix3f tempMatrix</declaration>
+                <declaration visibility="protected" type="com.bulletphysics.linearmath.Transform" name="tempTrans" signature="tempTrans" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.tempTrans">protected com.bulletphysics.linearmath.Transform tempTrans</declaration>
+                <declaration visibility="protected" type="javax.vecmath.Vector3f" name="tempVec" signature="tempVec" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.tempVec">protected javax.vecmath.Vector3f tempVec</declaration>
+                <declaration visibility="protected" type="javax.vecmath.Vector3f" name="tempVec2" signature="tempVec2" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.tempVec2">protected javax.vecmath.Vector3f tempVec2</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="void" signature="destroy()" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.destroy()" throws="">public void destroy()</declaration>
+                <declaration visibility="public" return-type="com.jme3.math.Vector3f" signature="getInterpolatedPhysicsLocation(com.jme3.math.Vector3f)" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.getInterpolatedPhysicsLocation(com.jme3.math.Vector3f)" throws="">public com.jme3.math.Vector3f getInterpolatedPhysicsLocation(com.jme3.math.Vector3f)</declaration>
+                <declaration visibility="public" return-type="com.jme3.math.Matrix3f" signature="getInterpolatedPhysicsRotation(com.jme3.math.Matrix3f)" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.getInterpolatedPhysicsRotation(com.jme3.math.Matrix3f)" throws="">public com.jme3.math.Matrix3f getInterpolatedPhysicsRotation(com.jme3.math.Matrix3f)</declaration>
+                <declaration visibility="public" return-type="com.bulletphysics.dynamics.RigidBody" signature="getObjectId()" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.getObjectId()" throws="">public com.bulletphysics.dynamics.RigidBody getObjectId()</declaration>
+                <declaration visibility="public" return-type="void" signature="setAngularDamping(float)" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.setAngularDamping(float)" throws="">public void setAngularDamping(float)</declaration>
+                <declaration visibility="public" return-type="void" signature="setLinearDamping(float)" full-signature="com.jme3.bullet.objects.PhysicsRigidBody.setLinearDamping(float)" throws="">public void setLinearDamping(float)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.PhysicsVehicle</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.vehicle.VehicleRaycaster" name="rayCaster" signature="rayCaster" full-signature="com.jme3.bullet.objects.PhysicsVehicle.rayCaster">protected com.bulletphysics.dynamics.vehicle.VehicleRaycaster rayCaster</declaration>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.vehicle.RaycastVehicle" name="vehicle" signature="vehicle" full-signature="com.jme3.bullet.objects.PhysicsVehicle.vehicle">protected com.bulletphysics.dynamics.vehicle.RaycastVehicle vehicle</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="void" signature="destroy()" full-signature="com.jme3.bullet.objects.PhysicsVehicle.destroy()" throws="">public void destroy()</declaration>
+            </removed-methods>
+            <modified-fields>
+                <feature>
+                    <name>com.jme3.bullet.objects.PhysicsVehicle.tuning</name>
+                    <modified-declaration>
+                        <old-declaration visibility="protected" type="com.bulletphysics.dynamics.vehicle.VehicleTuning" name="tuning" signature="tuning" full-signature="com.jme3.bullet.objects.PhysicsVehicle.tuning">protected com.bulletphysics.dynamics.vehicle.VehicleTuning tuning</old-declaration>
+                        <new-declaration visibility="protected" type="com.jme3.bullet.objects.infos.VehicleTuning" name="tuning" signature="tuning" full-signature="com.jme3.bullet.objects.PhysicsVehicle.tuning">protected com.jme3.bullet.objects.infos.VehicleTuning tuning</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-fields>
+            <modified-methods>
+                <feature>
+                    <name>com.jme3.bullet.objects.PhysicsVehicle.getVehicleId()</name>
+                    <modified-declaration>
+                        <old-declaration visibility="public" return-type="com.bulletphysics.dynamics.vehicle.RaycastVehicle" signature="getVehicleId()" full-signature="com.jme3.bullet.objects.PhysicsVehicle.getVehicleId()" throws="">public com.bulletphysics.dynamics.vehicle.RaycastVehicle getVehicleId()</old-declaration>
+                        <new-declaration visibility="public" return-type="long" signature="getVehicleId()" full-signature="com.jme3.bullet.objects.PhysicsVehicle.getVehicleId()" throws="">public long getVehicleId()</new-declaration>
+                    </modified-declaration>
+                </feature>
+            </modified-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.VehicleWheel</name>
+            <removed-fields>
+                <declaration visibility="protected" type="com.bulletphysics.dynamics.vehicle.WheelInfo" name="wheelInfo" signature="wheelInfo" full-signature="com.jme3.bullet.objects.VehicleWheel.wheelInfo">protected com.bulletphysics.dynamics.vehicle.WheelInfo wheelInfo</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" return-type="com.bulletphysics.dynamics.vehicle.WheelInfo" signature="getWheelInfo()" full-signature="com.jme3.bullet.objects.VehicleWheel.getWheelInfo()" throws="">public com.bulletphysics.dynamics.vehicle.WheelInfo getWheelInfo()</declaration>
+                <declaration visibility="public" return-type="void" signature="setWheelInfo(com.bulletphysics.dynamics.vehicle.WheelInfo)" full-signature="com.jme3.bullet.objects.VehicleWheel.setWheelInfo(com.bulletphysics.dynamics.vehicle.WheelInfo)" throws="">public void setWheelInfo(com.bulletphysics.dynamics.vehicle.WheelInfo)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.objects.infos.RigidBodyMotionState</name>
+            <modified-declaration>
+                <old-declaration visibility="public" super="yes" name="com.jme3.bullet.objects.infos.RigidBodyMotionState" extends="com.bulletphysics.linearmath.MotionState" implements="">public class com.jme3.bullet.objects.infos.RigidBodyMotionState extends com.bulletphysics.linearmath.MotionState</old-declaration>
+                <new-declaration visibility="public" super="yes" name="com.jme3.bullet.objects.infos.RigidBodyMotionState" extends="java.lang.Object" implements="">public class com.jme3.bullet.objects.infos.RigidBodyMotionState extends java.lang.Object</new-declaration>
+            </modified-declaration>
+            <removed-fields>
+                <declaration visibility="private" type="boolean" name="jmeLocationDirty" signature="jmeLocationDirty" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.jmeLocationDirty">private boolean jmeLocationDirty</declaration>
+                <declaration visibility="private" type="com.jme3.math.Vector3f" name="localLocation" signature="localLocation" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.localLocation">private com.jme3.math.Vector3f localLocation</declaration>
+                <declaration visibility="private" type="com.jme3.math.Quaternion" name="localRotationQuat" signature="localRotationQuat" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.localRotationQuat">private com.jme3.math.Quaternion localRotationQuat</declaration>
+                <declaration visibility="private" type="com.bulletphysics.linearmath.Transform" name="motionStateTrans" signature="motionStateTrans" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.motionStateTrans">private com.bulletphysics.linearmath.Transform motionStateTrans</declaration>
+                <declaration visibility="private" type="boolean" name="physicsLocationDirty" signature="physicsLocationDirty" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.physicsLocationDirty">private boolean physicsLocationDirty</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="public" synchronized="yes" return-type="com.bulletphysics.linearmath.Transform" signature="getWorldTransform(com.bulletphysics.linearmath.Transform)" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.getWorldTransform(com.bulletphysics.linearmath.Transform)" throws="">public synchronized com.bulletphysics.linearmath.Transform getWorldTransform(com.bulletphysics.linearmath.Transform)</declaration>
+                <declaration visibility="public" synchronized="yes" return-type="void" signature="setWorldTransform(com.bulletphysics.linearmath.Transform)" full-signature="com.jme3.bullet.objects.infos.RigidBodyMotionState.setWorldTransform(com.bulletphysics.linearmath.Transform)" throws="">public synchronized void setWorldTransform(com.bulletphysics.linearmath.Transform)</declaration>
+            </removed-methods>
+        </class>
+        <class>
+            <name>com.jme3.bullet.util.DebugShapeFactory</name>
+            <removed-fields>
+                <declaration visibility="private" static="yes" final="yes" type="javax.vecmath.Vector3f" name="aabbMax" signature="aabbMax" full-signature="com.jme3.bullet.util.DebugShapeFactory.aabbMax">private static final javax.vecmath.Vector3f aabbMax</declaration>
+                <declaration visibility="private" static="yes" final="yes" type="javax.vecmath.Vector3f" name="aabbMin" signature="aabbMin" full-signature="com.jme3.bullet.util.DebugShapeFactory.aabbMin">private static final javax.vecmath.Vector3f aabbMin</declaration>
+            </removed-fields>
+            <removed-methods>
+                <declaration visibility="private" static="yes" return-type="java.nio.FloatBuffer" signature="getVertices(com.bulletphysics.collision.shapes.ConcaveShape)" full-signature="com.jme3.bullet.util.DebugShapeFactory.getVertices(com.bulletphysics.collision.shapes.ConcaveShape)" throws="">private static java.nio.FloatBuffer getVertices(com.bulletphysics.collision.shapes.ConcaveShape)</declaration>
+                <declaration visibility="private" static="yes" return-type="java.nio.FloatBuffer" signature="getVertices(com.bulletphysics.collision.shapes.ConvexShape)" full-signature="com.jme3.bullet.util.DebugShapeFactory.getVertices(com.bulletphysics.collision.shapes.ConvexShape)" throws="">private static java.nio.FloatBuffer getVertices(com.bulletphysics.collision.shapes.ConvexShape)</declaration>
+            </removed-methods>
+        </class>
+    </modified-classes>
+</differences>
Index: lib/nblibraries.properties
===================================================================
--- lib/nblibraries.properties	(revision 8878)
+++ lib/nblibraries.properties	(working copy)
@@ -34,6 +34,7 @@
     ${base}/JWSAntTasks/org-netbeans-modules-javawebstart-anttasks.jar
 libs.lwjgl.classpath=\
     ${base}/lwjgl/lwjgl.jar;\
+    ${base}/lwjgl/lwjgl_util.jar:\
     ${base}/lwjgl/jME3-lwjgl-natives.jar;\
     ${base}/lwjgl/jinput.jar
 libs.lwjgl.src=\
Index: nbproject/project.xml
===================================================================
--- nbproject/project.xml	(revision 8878)
+++ nbproject/project.xml	(working copy)
@@ -30,6 +30,7 @@
                 <root id="src.test.dir" name="Test"/>
                 <root id="src.lwjgl.dir" name="LWJGL Renderer"/>
                 <root id="src.android.dir" name="Android Renderer"/>
+                <root id="src.swingGui.dir" name="SwingGui"/>
             </source-roots>
             <test-roots>
                 <root id="test.test.dir" name="Unit Test"/>
Index: src/core/com/jme3/animation/AnimChannel.java
===================================================================
--- src/core/com/jme3/animation/AnimChannel.java	(revision 8878)
+++ src/core/com/jme3/animation/AnimChannel.java	(working copy)
@@ -211,7 +211,7 @@
         if (blendTime < 0f)
             throw new IllegalArgumentException("blendTime cannot be less than zero");
 
-        Animation anim = control.animationMap.get(name);
+        Animation anim = control.getAnim(name);
         if (anim == null)
             throw new IllegalArgumentException("Cannot find animation named: '"+name+"'");
 
@@ -322,7 +322,7 @@
             return;
 
         if (blendFrom != null){
-            blendFrom.setTime(timeBlendFrom, 1f - blendAmount, control, this, vars);
+        	blendFrom.setTime(timeBlendFrom, 1f, control, this, vars);
             //blendFrom.setTime(timeBlendFrom, control.skeleton, 1f - blendAmount, affectedBones);
             timeBlendFrom += tpf * speedBlendFrom;
             timeBlendFrom = clampWrapTime(timeBlendFrom,
Index: src/core/com/jme3/animation/AnimControl.java
===================================================================
--- src/core/com/jme3/animation/AnimControl.java	(revision 8878)
+++ src/core/com/jme3/animation/AnimControl.java	(working copy)
@@ -76,9 +76,9 @@
     private SkeletonControl skeletonControl;
 
     /**
-     * List of animations
+     * An Animationprovider
      */
-    HashMap<String, Animation> animationMap;
+    private AnimationProvider animationProvider = new HashMapAnimationProvider();
 
     /**
      * Animation channels
@@ -107,6 +107,10 @@
      */
     public AnimControl() {
     }
+    
+    public void setAnimationProvider(AnimationProvider pro){
+    	this.animationProvider = pro;
+    }
 
     /**
      * Internal use only.
@@ -137,7 +141,7 @@
      * with the skeleton given in the constructor.
      */
     public void setAnimations(HashMap<String, Animation> animations) {
-        animationMap = animations;
+    	animationProvider.setAnimations(animations);
     }
 
     /**
@@ -147,7 +151,7 @@
      * such named animation exists.
      */
     public Animation getAnim(String name) {
-        return animationMap.get(name);
+        return animationProvider.getAnimation(name, this);
     }
 
     /**
@@ -156,7 +160,7 @@
      * @param anim The animation to add.
      */
     public void addAnim(Animation anim) {
-        animationMap.put(anim.getName(), anim);
+       animationProvider.addAnimation(anim);
     }
 
     /**
@@ -164,12 +168,7 @@
      * @param anim The animation to remove.
      */
     public void removeAnim(Animation anim) {
-        if (!animationMap.containsKey(anim.getName())) {
-            throw new IllegalArgumentException("Given animation does not exist "
-                    + "in this AnimControl");
-        }
-
-        animationMap.remove(anim.getName());
+        animationProvider.removeAnimation(anim.getName());
     }
 
     /**
@@ -296,7 +295,7 @@
      * can play.
      */
     public Collection<String> getAnimationNames() {
-        return animationMap.keySet();
+        return animationProvider.getAnimationNames();
     }
 
     /**
@@ -305,13 +304,7 @@
      * @return The length of time, in seconds, of the named animation.
      */
     public float getAnimationLength(String name) {
-        Animation a = animationMap.get(name);
-        if (a == null) {
-            throw new IllegalArgumentException("The animation " + name
-                    + " does not exist in this AnimControl");
-        }
-
-        return a.getLength();
+        return animationProvider.getAnimationLength(name);
     }
     
     /**
@@ -346,7 +339,7 @@
         super.write(ex);
         OutputCapsule oc = ex.getCapsule(this);
         oc.write(skeleton, "skeleton", null);
-        oc.writeStringSavableMap(animationMap, "animations", null);
+        oc.write(animationProvider, "animationProvider", null);
     }
 
     @Override
@@ -354,7 +347,7 @@
         super.read(im);
         InputCapsule in = im.getCapsule(this);
         skeleton = (Skeleton) in.readSavable("skeleton", null);
-        animationMap = (HashMap<String, Animation>) in.readStringSavableMap("animations", null);
+        animationProvider = (AnimationProvider) in.readSavable("animationProvider", null);
 
         if (im.getFormatVersion() == 0){
             // Changed for backward compatibility with j3o files generated 
Index: src/core/com/jme3/animation/Animation.java
===================================================================
--- src/core/com/jme3/animation/Animation.java	(revision 8878)
+++ src/core/com/jme3/animation/Animation.java	(working copy)
@@ -202,4 +202,26 @@
         tracks = new Track[arr.length];
         System.arraycopy(arr, 0, tracks, 0, arr.length);
     }
+    
+    
+    /**
+     * BoneTracks without a bone index but a bone name can be
+     * bound to the specified bone index. This can be used for
+     * loading animation tracks only and being able to play them
+     * on any bone or any skeleton, as long as the bone name does
+     * match
+     */
+    public void rewireBoneTracks(Skeleton skeleton) {
+		if(tracks != null){
+			for(Track tr : tracks){
+				if(tr instanceof BoneTrack){
+					BoneTrack bt = (BoneTrack) tr;
+				if(bt.getTargetBoneIndex() < 0)
+					bt.setTargetBoneIndex(skeleton.getBoneIndex(bt.getTargetBoneName()));
+				else
+					return;
+				}
+			}
+		}
+	}
 }
Index: src/core/com/jme3/animation/AnimationProvider.java
===================================================================
--- src/core/com/jme3/animation/AnimationProvider.java	(revision 0)
+++ src/core/com/jme3/animation/AnimationProvider.java	(revision 0)
@@ -0,0 +1,32 @@
+package com.jme3.animation;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+
+import com.jme3.export.JmeExporter;
+import com.jme3.export.JmeImporter;
+import com.jme3.export.Savable;
+
+public abstract class AnimationProvider implements Savable {
+
+	public AnimationProvider() {
+	}
+
+	public abstract void setAnimations(HashMap<String, Animation> animations);
+
+	public abstract Animation getAnimation(String name, AnimControl animControl);
+	
+	public abstract float getAnimationLength(String name);
+
+	public abstract void removeAnimation(String name);
+
+	public abstract void addAnimation(Animation anim);
+
+	public abstract Collection<String> getAnimationNames();
+
+	public abstract void write(JmeExporter ex) throws IOException;
+	
+	public abstract void read(JmeImporter im) throws IOException;
+
+}
\ No newline at end of file
Index: src/core/com/jme3/animation/BoneTrack.java
===================================================================
--- src/core/com/jme3/animation/BoneTrack.java	(revision 8878)
+++ src/core/com/jme3/animation/BoneTrack.java	(working copy)
@@ -48,8 +48,11 @@
     /**
      * Bone index in the skeleton which this track effects.
      */
-    private int targetBoneIndex;
-    
+    private int targetBoneIndex = -1;
+    /**
+     * Bone name in the skeleton which this track affects.
+     */
+    private String targetBoneName;
     /**
      * Transforms and times for track.
      */
@@ -97,6 +100,21 @@
         this.targetBoneIndex = targetBoneIndex;
     }
 
+    public BoneTrack(String boneName) {
+		this.targetBoneName = boneName;
+	}
+    
+    /**
+     * @return Target bone for this bonetrack
+     */
+    public String getTargetBoneName() {
+		return targetBoneName;
+	}
+    	
+	public void setTargetBoneIndex(int index) {
+        targetBoneIndex = index;
+    }
+
     /**
      * @return the bone index of this bone track.
      */
@@ -284,7 +302,8 @@
     @Override
     public void write(JmeExporter ex) throws IOException {
         OutputCapsule oc = ex.getCapsule(this);
-        oc.write(targetBoneIndex, "boneIndex", 0);
+        oc.write(targetBoneIndex, "boneIndex", -1);
+        oc.write(targetBoneName, "boneName", null);
         oc.write(translations, "translations", null);
         oc.write(rotations, "rotations", null);
         oc.write(times, "times", null);
@@ -294,7 +313,8 @@
     @Override
     public void read(JmeImporter im) throws IOException {
         InputCapsule ic = im.getCapsule(this);
-        targetBoneIndex = ic.readInt("boneIndex", 0);
+        targetBoneIndex = ic.readInt("boneIndex", -1);
+        targetBoneName = ic.readString("boneName", null);
 
         translations = (CompactVector3Array) ic.readSavable("translations", null);
         rotations = (CompactQuaternionArray) ic.readSavable("rotations", null);
Index: src/core/com/jme3/animation/HashMapAnimationProvider.java
===================================================================
--- src/core/com/jme3/animation/HashMapAnimationProvider.java	(revision 0)
+++ src/core/com/jme3/animation/HashMapAnimationProvider.java	(revision 0)
@@ -0,0 +1,86 @@
+package com.jme3.animation;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.HashMap;
+
+import com.jme3.export.InputCapsule;
+import com.jme3.export.JmeExporter;
+import com.jme3.export.JmeImporter;
+import com.jme3.export.OutputCapsule;
+
+/**
+ * An AnimationProvider based on a hasmap of animations
+ * 
+ */
+public class HashMapAnimationProvider extends AnimationProvider {
+
+	/**
+	 * List of animations
+	 */
+	protected HashMap<String, Animation> animationMap = new HashMap<String, Animation>();
+
+	/**
+	 * Sets the animations to the provided map of animation names to boneanimations
+	 */
+	public void setAnimations(HashMap<String, Animation> animations) {
+		this.animationMap = animations;
+	}
+
+	/**
+	 * Returns the animation requested by name or null if the animation does not exist
+	 */
+	public Animation getAnimation(String name, AnimControl control) {
+		return this.animationMap.get(name);
+	}
+
+	/**
+	 * Removes the specified animation specified by name or throws an IllegalStateException if the animation does not exisit in this provider
+	 */
+	public void removeAnimation(String name) {
+		if (!animationMap.containsKey(name)) {
+			throw new IllegalArgumentException(
+					"Given animation does not exist " + "in this AnimControl");
+		}
+
+		animationMap.remove(name);
+	}
+
+	/**
+	 * Adds an animation to the hash map
+	 */
+	public void addAnimation(Animation anim) {
+		animationMap.put(anim.getName(), anim);
+	}
+
+	/**
+	 * Returns a collection of the currently present animationnames
+	 */
+	public Collection<String> getAnimationNames() {
+		return animationMap.keySet();
+	}
+
+	/**
+	 * Returns the length of the given animation identified by name or throws an IllegalStateException if that animation is not present
+	 */
+	public float getAnimationLength(String name) {
+		Animation a = animationMap.get(name);
+		if (a == null) {
+			throw new IllegalArgumentException("The animation " + name
+					+ " does not exist in this AnimControl");
+		}
+
+		return a.getLength();
+	}
+
+	public void write(JmeExporter ex) throws IOException {
+		OutputCapsule oc = ex.getCapsule(this);
+		oc.writeStringSavableMap(animationMap, "animations", null);
+	}
+
+	public void read(JmeImporter im) throws IOException {
+		InputCapsule in = im.getCapsule(this);
+		animationMap = (HashMap<String, Animation>) in
+				.readStringSavableMap("animations", null);
+	}
+}
Index: src/core/com/jme3/asset/AssetConfig.java
===================================================================
--- src/core/com/jme3/asset/AssetConfig.java	(revision 8878)
+++ src/core/com/jme3/asset/AssetConfig.java	(working copy)
@@ -76,6 +76,8 @@
                 String rootPath = scan.next();
                 String locatorClass = scan.nextLine().trim();
                 manager.registerLocator(rootPath, locatorClass);
+            }else if (cmd.startsWith("#")){
+            	scan.nextLine();
             }else{
                 throw new IOException("Expected command, got '"+cmd+"'");
             }
Index: src/core/com/jme3/util/TangentBinormalGenerator.java
===================================================================
--- src/core/com/jme3/util/TangentBinormalGenerator.java	(revision 8878)
+++ src/core/com/jme3/util/TangentBinormalGenerator.java	(working copy)
@@ -31,21 +31,31 @@
  */
 package com.jme3.util;
 
+import static com.jme3.util.BufferUtils.populateFromBuffer;
+import static com.jme3.util.BufferUtils.setInBuffer;
+
+import java.nio.Buffer;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+import java.nio.ShortBuffer;
+import java.util.ArrayList;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
 import com.jme3.math.ColorRGBA;
 import com.jme3.math.FastMath;
 import com.jme3.math.Vector2f;
 import com.jme3.math.Vector3f;
-import com.jme3.scene.*;
+import com.jme3.scene.Geometry;
+import com.jme3.scene.Mesh;
+import com.jme3.scene.Mesh.Mode;
+import com.jme3.scene.Node;
+import com.jme3.scene.Spatial;
+import com.jme3.scene.VertexBuffer;
 import com.jme3.scene.VertexBuffer.Format;
 import com.jme3.scene.VertexBuffer.Type;
 import com.jme3.scene.VertexBuffer.Usage;
 import com.jme3.scene.mesh.IndexBuffer;
-import static com.jme3.util.BufferUtils.*;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.util.ArrayList;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 /**
  * 
@@ -736,4 +746,156 @@
         lineMesh.setInterleaved();
         return lineMesh;
     }
+    
+    
+    //TR CODE
+    
+    private static interface IndexWrapper {
+        public int get(int i);
+        public short getShort(int i);
+        public int size();
+    }
+    
+    private static IndexWrapper getIndexWrapper(final Buffer buff) {
+        if (buff instanceof ShortBuffer) {
+            return new IndexWrapper() {
+                private ShortBuffer buf = (ShortBuffer) buff;
+                public int get(int i) {
+                    return ((int) buf.get(i))&(0x0000FFFF);
+                }
+                public short getShort(int i){return buf.get(i);}
+                public int size() {
+                    return buf.capacity();
+                }
+            };
+        }
+        else if (buff instanceof IntBuffer) {
+            return new IndexWrapper() {
+                private IntBuffer buf = (IntBuffer) buff;
+                public int get(int i) {
+                    return buf.get(i);
+                }
+                public int size() {
+                    return buf.capacity();
+                }
+				@Override
+				public short getShort(int i) {
+					return 0;
+				}
+            };
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+    public static boolean generateFaceNormalsAndTangents(Mesh mesh){
+
+    	if(mesh.getMode() != Mode.Triangles)
+    		return false;
+    	
+        IndexWrapper indexBuffer =  getIndexWrapper(mesh.getBuffer(Type.Index).getData());
+        FloatBuffer vertexBuffer = (FloatBuffer) mesh.getBuffer(Type.Position).getData();
+        if (mesh.getBuffer(Type.TexCoord) == null)
+            throw new IllegalArgumentException("Can only generate tangents for "
+                                             + "meshes with texture coordinates");
+        
+        FloatBuffer textureBuffer = (FloatBuffer) mesh.getBuffer(Type.TexCoord).getData();
+        FloatBuffer tangents = BufferUtils.createFloatBuffer(vertexBuffer.capacity());
+        FloatBuffer normals = BufferUtils.createFloatBuffer(vertexBuffer.capacity());
+
+        Vector3f v1 = new Vector3f();
+        Vector3f v2 = new Vector3f();
+        Vector3f v3 = new Vector3f();
+        Vector2f t1 = new Vector2f();
+        Vector2f t2 = new Vector2f();
+        Vector2f t3 = new Vector2f();
+        for (int i = 0; i < indexBuffer.size(); i+=3) {
+            	int i1 = indexBuffer.get(i);
+                populateFromBuffer(v1, vertexBuffer, i1);
+                populateFromBuffer(t1, textureBuffer, i1);
+            	int i2 = indexBuffer.get(i+1);
+                populateFromBuffer(v2, vertexBuffer, i2);
+                populateFromBuffer(t2, textureBuffer, i2);
+            	int i3 = indexBuffer.get(i+2);
+                populateFromBuffer(v3, vertexBuffer, i3);
+                populateFromBuffer(t3, textureBuffer, i3);
+                
+                Vector3f v21 = v2.subtract(v1);
+                Vector3f v31 = v3.subtract(v1);
+                Vector2f t21 = t2.subtract(t1);
+                Vector2f t31 = t3.subtract(t1);
+                
+                Vector3f fNormal = v21.cross(v31);
+                fNormal.normalizeLocal();
+                Vector3f fTangent;
+                if(t21.y<0.000001f && t21.y>-0.000001f){
+                	if(t31.y<0.000001f && t31.y>-0.000001f){
+                		fTangent = Vector3f.UNIT_XYZ.clone();
+                    } else {
+                    	fTangent = v31.divide(t31.y);
+                    }
+                } else {
+                	fTangent = v21.divide(t21.y);
+                }
+                fTangent.normalizeLocal();
+                tangents.put(i1*3, fTangent.x);
+                tangents.put(i1*3+1, fTangent.y);
+                tangents.put(i1*3+2, fTangent.z);
+                tangents.put(i2*3, fTangent.x);
+                tangents.put(i2*3+1, fTangent.y);
+                tangents.put(i2*3+2, fTangent.z);
+                tangents.put(i3*3, fTangent.x);
+                tangents.put(i3*3+1, fTangent.y);
+                tangents.put(i3*3+2, fTangent.z);
+                normals.put(i1*3, fTangent.x);
+                normals.put(i1*3+1, fTangent.y);
+                normals.put(i1*3+2, fTangent.z);
+                normals.put(i2*3, fTangent.x);
+                normals.put(i2*3+1, fTangent.y);
+                normals.put(i2*3+2, fTangent.z);
+                normals.put(i3*3, fTangent.x);
+                normals.put(i3*3+1, fTangent.y);
+                normals.put(i3*3+2, fTangent.z);
+        }
+        mesh.clearBuffer(Type.Normal);
+        mesh.clearBuffer(Type.Tangent);
+        mesh.setBuffer(Type.Normal, 3, normals);
+        mesh.setBuffer(Type.Tangent, 3, tangents);
+        return true;
+    }
+    
+    /**
+     * Fix the normals of vertices lying on the edge of a tile to face a direction ON the edge. The result will be
+     * that two tiles corrected by this way will do not have seams on adjecant vertices.
+     * The algorithm works by moving the normal x and z values to 0 if the vertex is on the corresponding border.
+     * @param mesh				The mesh, normals should be fixed
+     * @param borderDistance	The distance from the center to one border, asuming all 4 borders at same distance
+     * @param borderTolerance	The positive tolerance value for checks if a vertex is on the border. Anything vertex within that distance to a border will be fixed.
+     */
+    public static void fixTileNormals(Mesh mesh, float borderDistance, float borderTolerance){
+        FloatBuffer vertexBuffer = (FloatBuffer) mesh.getBuffer(Type.Position).getData();
+        FloatBuffer normalBuffer = (FloatBuffer) mesh.getBuffer(Type.Normal).getData();
+        FloatBuffer normals = BufferUtils.createFloatBuffer(vertexBuffer.capacity());
+        Vector3f v = new Vector3f();
+        Vector3f n = new Vector3f();
+        //just loop over all values, whatever type it is, a vertex has its normal at the corresponding index
+        for (int i = 0; i < vertexBuffer.capacity()/3; i++) {
+                populateFromBuffer(v, vertexBuffer, i);
+                populateFromBuffer(n, normalBuffer, i);
+                
+                //on left or right border, the set x comp of normal to 0
+                if(FastMath.abs(v.x+borderDistance) <=borderTolerance) n.x = 0f;
+                else if(FastMath.abs(-v.x+borderDistance) <=borderTolerance) n.x = 0f;
+                //on top or bottom border, the set z comp of normal to 0
+                if(FastMath.abs(v.z+borderDistance) <=borderTolerance) n.z = 0f;
+                else if(FastMath.abs(-v.z+borderDistance) <=borderTolerance) n.z = 0f;
+                
+                n.normalizeLocal();
+                normals.put(n.x);
+                normals.put(n.y);
+                normals.put(n.z);
+        }
+        mesh.clearBuffer(Type.Normal);
+        mesh.setBuffer(Type.Normal, 3, normals);
+    }
+    //TR CODE END
 }
Index: src/ogre/com/jme3/scene/plugins/ogre/MeshLoader.java
===================================================================
--- src/ogre/com/jme3/scene/plugins/ogre/MeshLoader.java	(revision 8878)
+++ src/ogre/com/jme3/scene/plugins/ogre/MeshLoader.java	(working copy)
@@ -220,6 +220,27 @@
             if (materialList != null) {
                 mat = materialList.get(matName);
             }
+            if (mat == null) {
+            	try{
+	                Object o = assetManager.loadAsset(matName+".material");
+	                if(o instanceof MaterialList){
+	                	if(materialList != null)
+	                		materialList.putAll((MaterialList)o);
+	                	else {
+	                		materialList = new MaterialList();
+	                		materialList.putAll((MaterialList)o);
+	                	}
+	                	mat = materialList.get(matName);
+	                }
+	                else {
+	                	logger.log(Level.WARNING, "Material {0} not found. Applying default material", matName);
+	                	mat = (Material) assetManager.loadAsset(new AssetKey("Common/Materials/RedColor.j3m"));
+	                }
+            	} catch(Exception e){
+            		logger.log(Level.WARNING, "Material {0} not found. Applying default material", matName);
+            		mat = (Material) assetManager.loadMaterial("Common/Materials/RedColor.j3m");
+            		}
+            }
         }
         
         if (mat == null) {
@@ -259,9 +280,9 @@
         }
 
         if (meshName == null) {
-            geom = new Geometry("OgreSubmesh-" + (++meshIndex), mesh);
+            geom = new Geometry("OgreSubmesh");// + (++geomIdx), mesh);
         } else {
-            geom = new Geometry(meshName + "-geom-" + (++meshIndex), mesh);
+            geom = new Geometry(meshName, mesh);// + "-geom-" + (++geomIdx), mesh);
         }
 
         if (usesSharedVerts) {
@@ -720,7 +741,7 @@
     }
 
     private Node compileModel() {
-        Node model = new Node(meshName + "-ogremesh");
+        Node model = new Node(meshName);// + "-ogremesh");
 
         for (int i = 0; i < geoms.size(); i++) {
             Geometry g = geoms.get(i);
@@ -809,6 +830,11 @@
             if (folderName != null && folderName.length() > 0) {
                 meshName = meshName.substring(folderName.length());
             }
+            //Hack for Windows names not properly done in AssetKey
+            int last = meshName.lastIndexOf("\\");
+            if(last != -1)
+            	meshName = (meshName.substring(last+1));
+            
             assetManager = info.getManager();
 
             if (key instanceof OgreMeshKey) {
Index: src/ogre/com/jme3/scene/plugins/ogre/SkeletonLoader.java
===================================================================
--- src/ogre/com/jme3/scene/plugins/ogre/SkeletonLoader.java	(revision 8878)
+++ src/ogre/com/jme3/scene/plugins/ogre/SkeletonLoader.java	(working copy)
@@ -101,8 +101,11 @@
             assert elementStack.peek().equals("tracks");
             String boneName = SAXUtil.parseString(attribs.getValue("bone"));
             Bone bone = nameToBone.get(boneName);
-            int index = skeleton.getBoneIndex(bone);
-            track = new BoneTrack(index);
+            if(skeleton != null){
+	            int index = skeleton.getBoneIndex(bone);
+	            track = new BoneTrack(index);
+            }else
+            	track = new BoneTrack(boneName);
         } else if (qName.equals("boneparent")) {
             assert elementStack.peek().equals("bonehierarchy");
             String boneName = attribs.getValue("bone");
@@ -125,7 +128,8 @@
             assert elementStack.peek().equals("animations");
             String name = SAXUtil.parseString(attribs.getValue("name"));
             float length = SAXUtil.parseFloat(attribs.getValue("length"));
-            animation = new Animation(name, length);
+            //TR HACK, otherwise names in anim and boneanim do not match, FIX YOUR ASSETS and remove this !
+            animation = new Animation(name.toLowerCase(), length);
         } else if (qName.equals("bonehierarchy")) {
             assert elementStack.peek().equals("skeleton");
         } else if (qName.equals("animations")) {
@@ -165,6 +169,8 @@
             indexToBone.clear();
             skeleton = new Skeleton(bones);
         } else if (qName.equals("animation")) {
+        	if(animations == null)
+        		animations = new ArrayList<Animation>();
             animations.add(animation);
             animation = null;
         } else if (qName.equals("track")) {
Index: src/swingGui/com/jme3/math/TransformMatrix.java
===================================================================
--- src/swingGui/com/jme3/math/TransformMatrix.java	(revision 0)
+++ src/swingGui/com/jme3/math/TransformMatrix.java	(revision 0)
@@ -0,0 +1,518 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.math;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.logging.Logger;
+
+import com.jme3.scene.Spatial;
+//import com.jme3.system.JmeException;
+import com.jme3.export.InputCapsule;
+import com.jme3.export.JmeExporter;
+import com.jme3.export.JmeImporter;
+import com.jme3.export.OutputCapsule;
+import com.jme3.export.Savable;
+
+/**
+ * TransformMatrix holds a rotation (Matrix3f)  and translation (Vector3f) for point manipulation
+ *
+ * @author Jack Lindamood
+ * @author Joshua Slack
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ * Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class TransformMatrix  implements Serializable, Savable, Cloneable {
+    private static final Logger logger = Logger.getLogger(TransformMatrix.class
+            .getName());
+    
+    // TODO: Clean up and standardize this class's functionality
+    private static final long serialVersionUID = 1L;
+
+    private Matrix3f rot=new Matrix3f();
+    private Vector3f translation=new Vector3f();
+    private Vector3f scale=new Vector3f(1,1,1);
+
+    /**
+     * Constructor instantiates a new <code>TransformMatrix</code> that is set to the
+     * identity matrix by default.
+     *
+     */
+    public TransformMatrix() {
+    }
+
+    /**
+     * Constructor instantiates a new <code>TransformMatrix</code> that is set to the
+     * provided matrix. This constructor copies a given matrix. If the
+     * provided matrix is null, the constructor sets the matrix to the
+     * identity.
+     * @param mat the matrix to copy.
+     */
+    public TransformMatrix(TransformMatrix mat) {
+        set(mat);
+    }
+
+    /**
+     * Constructor instantiates a new <code>TransformMatrix</code> that has rotation
+     * and translation defined by its parameters
+     * @param myRot The given rotation, as a <code>Quaternion</code>
+     * @param myPos The given translation, as a <code>Vector3f</code>
+     */
+    public TransformMatrix(Quaternion myRot, Vector3f myPos) {
+        rot.set(myRot);
+        translation.set(myPos);
+    }
+
+    /**
+     * <code>set</code> copies the contents of a given matrix to this
+     * matrix. If a null matrix is supplied, this matrix is set to the
+     * identity matrix.
+     * @param matrix the matrix to copy.
+     */
+    public void set(TransformMatrix matrix) {
+        if (matrix == null) {
+            loadIdentity();
+        } else {
+            rot.set(matrix.rot);
+            translation.set(matrix.translation);
+            scale.set(matrix.scale);
+        }
+    }
+
+
+    /**
+     *
+     * <code>set</code> defines the values of the matrix based on a supplied
+     * <code>Quaternion</code> (which it does not modify).
+     * It should be noted that all previous values will be overridden.
+     * @param quaternion the quaternion to create a rotational matrix from.
+     */
+    public void set(Quaternion quaternion) {
+        rot.set(quaternion);
+        translation.zero();
+        scale.set(1,1,1);
+    }
+
+    /**
+     * <code>loadIdentity</code> sets this matrix to the identity matrix,
+     * namely all zeros with ones along the diagonal.
+     *
+     */
+    public void loadIdentity() {
+        rot.loadIdentity();
+        translation.zero();
+        scale.set(1,1,1);
+    }
+
+    /**
+     * Multiplies every value in the matrix by a scalar
+     * @param scalar
+     */
+    public void mult(float scalar) {
+        rot.multLocal(scalar);
+        translation.mult(scalar);
+        scale.multLocal(scalar);
+    }
+
+    /**
+     * <code>multLocal</code> multiplies this matrix with another matrix and stores
+     * the result back in this, returning this.  if null is passed, nothing happens
+     * This function changes this matrix to what the child would look like if this were applied as it's parent
+     *
+     * @param child The matrix to multiply by
+     * @param tempStore A temporary Vector3f object for this TransformMatrix to use during the calculation.
+     * @return this matrix after multiplication
+     */
+    public TransformMatrix multLocal(TransformMatrix child,Vector3f tempStore){
+        this.scale.multLocal(child.scale);
+        this.translation.addLocal(rot.mult(child.translation,tempStore).multLocal(child.scale));
+        this.rot.multLocal(child.rot);
+        return this;
+    }
+
+    /**
+     * Sets this transform to an interpolation between the start and end transforms.  Note that
+     * this function isn't very efficient as it has to create 2 new Quaternions to do the
+     * rotation interpolation
+     * @param start Begining transform (delta=0)
+     * @param end Ending transform (delta=1)
+     * @param delta Value between 0.0 and 1.0 to show which side the transform leans towards
+     */
+    public void interpolateTransforms(TransformMatrix start,TransformMatrix end,float delta){
+        this.translation.set(start.translation).interpolate(end.translation,delta);
+        this.scale.set(start.scale).interpolate(end.scale,delta);
+        Quaternion q1=new Quaternion(),q2=new Quaternion();
+        start.getRotation(q1);
+        end.getRotation(q2);
+        q1.slerp(q2,delta);
+        this.setRotationQuaternion(q1);
+    }
+
+    /**
+     * Sets this transform to an interpolation between the start and end transforms.  Same as above but doesn't
+     * create 2 new Quaternions
+     * @param start Begining transform (delta=0)
+     * @param end Ending transform (delta=1)
+     * @param delta Value between 0.0 and 1.0 to show which side the transform leans towards
+     * @param q1 A temporary Quaternion
+     * @param q2 Another temporary Quaternion
+     */
+    public void interpolateTransforms(TransformMatrix start,TransformMatrix end,float delta,Quaternion q1,Quaternion q2){
+        this.translation.set(start.translation).interpolate(end.translation,delta);
+        this.scale.set(start.scale).interpolate(end.scale,delta);
+        start.getRotation(q1);
+        end.getRotation(q2);
+        q1.slerp(q2,delta);
+        this.setRotationQuaternion(q1);
+    }
+
+
+    /**
+     * <code>mult</code> multiplies a normal about a transform matrix and
+     * stores the result back in vec. The resulting vector is returned
+     * with translational ignored.
+     * @param vec the rotation normal.
+     * @return The given Vector3f, after rotation
+     */
+    public Vector3f multNormal(Vector3f vec) {
+        if (null == vec) {
+            logger.warning("Source vector is null, null result returned.");
+            return null;
+        }
+        return rot.multLocal(vec);
+    }
+
+    /**
+     * <code>mult</code> multiplies a vector about a transform matrix. The
+     * resulting vector is saved in vec and returned.
+     * @param vec The point to rotate.
+     * @return The rotated vector.
+     */
+    public Vector3f multPoint(Vector3f vec) {
+        if (null == vec) {
+            logger.warning("Source vector is null, null result returned.");
+            return null;
+        }
+        return rot.multLocal(vec).multLocal(scale).addLocal(translation);
+    }
+
+
+    /**
+     * Sets the rotation matrix to the given rotation matrix via a copy.  If null is supplied, the identity is set
+     * @param rot The new rotation
+     */
+    public void setRotation(Matrix3f rot){
+        this.rot.set(rot);
+    }
+
+    /**
+     * <code>setTranslation</code> will set the matrix's translation values.
+     * @param transArray the new values for the translation.
+     * @throws RuntimeException if translation is null or not size 3.
+     */
+    public void setTranslation(float[] transArray) {
+        if (transArray == null || transArray.length != 3) {
+            throw new RuntimeException("Translation size must be 3.");
+        }
+        translation.x = transArray[0];
+        translation.y = transArray[1];
+        translation.z = transArray[2];
+    }
+
+    /** <code>setTranslation</code> will copy the given Vector3f's values
+     * into this Matrix's translational component
+     *
+     * @param trans
+     */
+    public void setTranslation(Vector3f trans){
+        if (trans==null){
+            throw new RuntimeException("Vector3f translation must be non-null");
+        }
+        translation.set(trans);
+    }
+
+    /**
+     * Sets the Transform's Translational component
+     * @param x New X translation
+     * @param y New Y translation
+     * @param z New Z translation
+     */
+    public void setTranslation(float x,float y,float z){
+        translation.set(x,y,z);
+    }
+
+    /**
+     * Sets the rotational component of this transform to the matrix represented
+     * by an Euler rotation about x, y, then z.
+     * @param x The X rotation, in radians
+     * @param y The Y rotation, in radians
+     * @param z The Z rotation, in radians
+     */
+    public void setEulerRot(float x,float y,float z){
+        double A = Math.cos(x);
+        double B = Math.sin(x);
+        double C = Math.cos(y);
+        double D = Math.sin(y);
+        double E = Math.cos(z);
+        double F = Math.sin(z);
+        double AD =   A * D;
+        double BD =   B * D;
+        rot.m00 = (float) (C * E);
+        rot.m01 = (float) (BD * E + -(A * F));
+        rot.m02 = (float) (AD * E + B * F);
+        rot.m10 = (float) (C * F);
+        rot.m11 = (float) (BD * F + A * E);
+        rot.m12 = (float) (AD * F + -(B * E));
+        rot.m20 = (float) -D;
+        rot.m21 = (float) (B * C);
+        rot.m22 = (float) (A * C);
+    }
+
+    /**
+     * <code>setRotationQuaternion</code> builds a rotation from a
+     * <code>Quaternion</code>.
+     * @param quat The quaternion to build the rotation from.
+     * @throws RuntimeException if quat is null.
+     */
+    public void setRotationQuaternion(Quaternion quat) {
+        if (null == quat) {
+            throw new RuntimeException("Quat may not be null.");
+        }
+        rot.set(quat);
+    }
+
+    /**
+     * <code>invertRotInPlace</code> inverts the rotational component of this Matrix
+     * in place
+     */
+    private void invertRotInPlace() {
+        float temp;
+        temp=rot.m01;
+        rot.m01=rot.m10;
+        rot.m10=temp;
+        temp=rot.m02;
+        rot.m02=rot.m20;
+        rot.m20=temp;
+        temp=rot.m21;
+        rot.m21=rot.m12;
+        rot.m12=temp;
+
+    }
+
+
+    /**
+     * Stores the rotational part of this matrix into the passed matrix.
+     * Will create a new Matrix3f if given matrix is null.  Returns the
+     * given matrix after it has been loaded with rotation values, to allow
+     * chaining
+     *
+     * @param rotStore The matrix to store rotation values
+     * @return The given matrix with updated values
+     */
+    public Matrix3f getRotation(Matrix3f rotStore){
+        if (rotStore==null) rotStore=new Matrix3f();
+        rotStore.set(rot);
+        return rotStore;
+    }
+
+    /**
+     * Stores the translational part of this matrix into the passed matrix.
+     * Will create a new Vector3f if given vector is null.  Returns the
+     * given vector after it has been loaded with translation values, to allow
+     * chaining
+     *
+     * @param tranStore The vector to store translation values
+     * @return The given Vector with updated values
+     */
+    public Vector3f getTranslation(Vector3f tranStore){
+        if (tranStore==null) tranStore=new Vector3f();
+        tranStore.set(translation);
+        return tranStore;
+    }
+
+    /**
+     * Stores the rotational part of this matrix into the passed Quaternion.
+     * Will create a new Quaternion if given quaternion is null.  Returns the
+     * given Quaternion after it has been loaded with rotation values, to allow
+     * chaining
+     *
+     * @param rotStore The Quat to store translation values
+     * @return The given Vector with updated values
+     */
+    public Quaternion getRotation(Quaternion rotStore){
+        if (rotStore==null) rotStore=new Quaternion();
+        rotStore.fromRotationMatrix(rot);
+        return rotStore;
+    }
+
+    /**
+     * <code>toString</code> returns the string representation of this object.
+     * It is simply a toString() call of the rotational matrix and the translational vector
+     * @return the string representation of this object.
+     */
+    public String toString() {
+        return TransformMatrix.class.getName() + " [\n"+
+                rot.toString() + ":" +
+                translation.toString() + ":" +
+                scale.toString() + "\n]";
+    }
+
+    /**
+     * <code>inverse</code> turns this matrix into it's own inverse
+     */
+    public void inverse() {
+        invertRotInPlace();
+        rot.multLocal(translation);
+        translation.multLocal(-1);
+        scale.set(1/scale.x,1/scale.y,1/scale.z);
+    }
+
+    /**
+     * <code>setEulerRot</code> is equivalent to
+     * setEulerRot(eulerVec.x,eulverVec.y,eulverVec.z){
+     * @param eulerVec A Vector3f representing the new rotation in Euler angles
+     */
+    public void setEulerRot(Vector3f eulerVec) {
+        this.setEulerRot(eulerVec.x,eulerVec.y,eulerVec.z);
+    }
+
+    /**
+     * <code>set</code> changes this matrix's rotational and translational components
+     * to that represented by the given parameters, by copying.
+     * @param rotation The new rotaiton
+     * @param translation The new translation
+     */
+    public void set(Quaternion rotation, Vector3f translation) {
+        this.set(rotation);
+        this.setTranslation(translation);
+    }
+
+    /**
+     * Sets this TransformMatrix's scale to the given scale (x,y,z), by copying.
+     * @param scale The new scale
+     */
+    public void setScale(Vector3f scale) {
+        this.scale.set(scale);
+    }
+
+    /**
+     * Sets this TransformMatrix's scale to the given x,y,z
+     * @param x The x scale
+     * @param y The y scale
+     * @param z The z scale
+     */
+    public void setScale(float x, float y, float z) {
+        scale.set(x,y,z);
+    }
+
+    /**
+     * Returns this TransformMatrix's scale factor
+     * @param storeS The place to store the current scale factor
+     * @return The given scale factor
+     */
+    public Vector3f getScale(Vector3f storeS) {
+        if (storeS==null) storeS=new Vector3f();
+        return storeS.set(this.scale);
+    }
+
+    /**
+     * Applies this TransformMatrix to the given spatial, by updating the
+     * spatial's local translation, rotation, scale.
+     * The spatial's transform values are replaced absolutely, not relatively.
+     *
+     * @param spatial The spatial to update
+     */
+    public void applyToSpatial(Spatial spatial) {
+        spatial.setLocalTranslation(translation);
+        spatial.setLocalRotation(rot);
+        spatial.setLocalScale(scale);
+    }
+
+    /**
+     * Combines this TransformMatrix with a parent TransformMatrix.
+     * @param parent The parent matrix.
+     * @return This matrix, after it has been updated by it's parent.
+     */
+    public TransformMatrix combineWithParent(TransformMatrix parent){
+        this.scale.multLocal(parent.scale);
+        this.rot.multLocal(parent.rot);
+        parent.rot.multLocal(this.translation).multLocal(parent.scale).addLocal(parent.translation);
+        return this;
+
+    }
+
+    public void write(JmeExporter e) throws IOException {
+        OutputCapsule capsule = e.getCapsule(this);
+        capsule.write(rot, "rot", new Matrix3f());
+        capsule.write(translation, "translation", Vector3f.ZERO);
+        capsule.write(scale, "scale", Vector3f.UNIT_XYZ);
+    }
+
+    public void read(JmeImporter e) throws IOException {
+        InputCapsule capsule = e.getCapsule(this);
+        rot = (Matrix3f)capsule.readSavable("rot", new Matrix3f());
+        translation = (Vector3f)capsule.readSavable("translation", Vector3f.ZERO.clone());
+        scale = (Vector3f)capsule.readSavable("scale", Vector3f.UNIT_XYZ.clone());
+    }
+    
+    public Class<? extends TransformMatrix> getClassTag() {
+        return this.getClass();
+    }
+
+    @Override
+    public int hashCode() {
+        return rot.hashCode() * 2 + translation.hashCode() * 3
+            + scale.hashCode() * 5;
+    }
+
+    @Override
+    public boolean equals(Object oIn) {
+        if (oIn.getClass() != TransformMatrix.class) return false;
+        TransformMatrix o = (TransformMatrix) oIn;
+        return rot.equals(o.rot) && translation.equals(o.translation)
+                && scale.equals(o.scale);
+    }
+
+    @Override
+    public TransformMatrix clone() {
+        try {
+            TransformMatrix tm = (TransformMatrix) super.clone();
+            tm.rot = rot.clone();
+            tm.scale = scale.clone();
+            tm.translation = translation.clone();
+            return tm;
+        } catch (CloneNotSupportedException e) {
+            throw new AssertionError();
+        }
+    }
+}
Index: src/swingGui/com/jme3/swingGui/AWTKeyInput.java
===================================================================
--- src/swingGui/com/jme3/swingGui/AWTKeyInput.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/AWTKeyInput.java	(revision 0)
@@ -0,0 +1,291 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors 
+ *   may be used to endorse or promote products derived from this software 
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.jme3.swingGui;
+
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import java.util.BitSet;
+import java.util.LinkedList;
+import java.util.logging.Logger;
+
+import com.jme3.input.KeyInput;
+
+/**
+ * <code>AWTKeyInput</code>
+ *
+ * @author Joshua Slack
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ * @version $Revision: 4133 $
+ */
+public class AWTKeyInput {
+    private static final Logger logger = Logger.getLogger(AWTKeyInput.class.getName());
+
+    /**
+     * <code>toAWTCode</code> converts KeyInput key codes to AWT key codes.
+     *
+     * @param key jme KeyInput key code
+     * @return awt KeyEvent key code
+     */
+    public static int toAWTCode( int key ) {
+        switch ( key ) {
+            case KeyInput.KEY_ESCAPE:
+                return KeyEvent.VK_ESCAPE;
+            case KeyInput.KEY_1:
+                return KeyEvent.VK_1;
+            case KeyInput.KEY_2:
+                return KeyEvent.VK_2;
+            case KeyInput.KEY_3:
+                return KeyEvent.VK_3;
+            case KeyInput.KEY_4:
+                return KeyEvent.VK_4;
+            case KeyInput.KEY_5:
+                return KeyEvent.VK_5;
+            case KeyInput.KEY_6:
+                return KeyEvent.VK_6;
+            case KeyInput.KEY_7:
+                return KeyEvent.VK_7;
+            case KeyInput.KEY_8:
+                return KeyEvent.VK_8;
+            case KeyInput.KEY_9:
+                return KeyEvent.VK_9;
+            case KeyInput.KEY_0:
+                return KeyEvent.VK_0;
+            case KeyInput.KEY_MINUS:
+                return KeyEvent.VK_MINUS;
+            case KeyInput.KEY_EQUALS:
+                return KeyEvent.VK_EQUALS;
+            case KeyInput.KEY_BACK:
+                return KeyEvent.VK_BACK_SPACE;
+            case KeyInput.KEY_TAB:
+                return KeyEvent.VK_TAB;
+            case KeyInput.KEY_Q:
+                return KeyEvent.VK_Q;
+            case KeyInput.KEY_W:
+                return KeyEvent.VK_W;
+            case KeyInput.KEY_E:
+                return KeyEvent.VK_E;
+            case KeyInput.KEY_R:
+                return KeyEvent.VK_R;
+            case KeyInput.KEY_T:
+                return KeyEvent.VK_T;
+            case KeyInput.KEY_Y:
+                return KeyEvent.VK_Y;
+            case KeyInput.KEY_U:
+                return KeyEvent.VK_U;
+            case KeyInput.KEY_I:
+                return KeyEvent.VK_I;
+            case KeyInput.KEY_O:
+                return KeyEvent.VK_O;
+            case KeyInput.KEY_P:
+                return KeyEvent.VK_P;
+            case KeyInput.KEY_LBRACKET:
+                return KeyEvent.VK_OPEN_BRACKET;
+            case KeyInput.KEY_RBRACKET:
+                return KeyEvent.VK_CLOSE_BRACKET;
+            case KeyInput.KEY_RETURN:
+                return KeyEvent.VK_ENTER;
+            case KeyInput.KEY_LCONTROL:
+                return KeyEvent.VK_CONTROL;
+            case KeyInput.KEY_A:
+                return KeyEvent.VK_A;
+            case KeyInput.KEY_S:
+                return KeyEvent.VK_S;
+            case KeyInput.KEY_D:
+                return KeyEvent.VK_D;
+            case KeyInput.KEY_F:
+                return KeyEvent.VK_F;
+            case KeyInput.KEY_G:
+                return KeyEvent.VK_G;
+            case KeyInput.KEY_H:
+                return KeyEvent.VK_H;
+            case KeyInput.KEY_J:
+                return KeyEvent.VK_J;
+            case KeyInput.KEY_K:
+                return KeyEvent.VK_K;
+            case KeyInput.KEY_L:
+                return KeyEvent.VK_L;
+            case KeyInput.KEY_SEMICOLON:
+                return KeyEvent.VK_SEMICOLON;
+            case KeyInput.KEY_APOSTROPHE:
+                return KeyEvent.VK_QUOTE;
+            case KeyInput.KEY_GRAVE:
+                return KeyEvent.VK_DEAD_GRAVE;
+            case KeyInput.KEY_LSHIFT:
+                return KeyEvent.VK_SHIFT;
+            case KeyInput.KEY_BACKSLASH:
+                return KeyEvent.VK_BACK_SLASH;
+            case KeyInput.KEY_Z:
+                return KeyEvent.VK_Z;
+            case KeyInput.KEY_X:
+                return KeyEvent.VK_X;
+            case KeyInput.KEY_C:
+                return KeyEvent.VK_C;
+            case KeyInput.KEY_V:
+                return KeyEvent.VK_V;
+            case KeyInput.KEY_B:
+                return KeyEvent.VK_B;
+            case KeyInput.KEY_N:
+                return KeyEvent.VK_N;
+            case KeyInput.KEY_M:
+                return KeyEvent.VK_M;
+            case KeyInput.KEY_COMMA:
+                return KeyEvent.VK_COMMA;
+            case KeyInput.KEY_PERIOD:
+                return KeyEvent.VK_PERIOD;
+            case KeyInput.KEY_SLASH:
+                return KeyEvent.VK_SLASH;
+            case KeyInput.KEY_RSHIFT:
+                return KeyEvent.VK_SHIFT;
+            case KeyInput.KEY_MULTIPLY:
+                return KeyEvent.VK_MULTIPLY;
+            case KeyInput.KEY_SPACE:
+                return KeyEvent.VK_SPACE;
+            case KeyInput.KEY_CAPITAL:
+                return KeyEvent.VK_CAPS_LOCK;
+            case KeyInput.KEY_F1:
+                return KeyEvent.VK_F1;
+            case KeyInput.KEY_F2:
+                return KeyEvent.VK_F2;
+            case KeyInput.KEY_F3:
+                return KeyEvent.VK_F3;
+            case KeyInput.KEY_F4:
+                return KeyEvent.VK_F4;
+            case KeyInput.KEY_F5:
+                return KeyEvent.VK_F5;
+            case KeyInput.KEY_F6:
+                return KeyEvent.VK_F6;
+            case KeyInput.KEY_F7:
+                return KeyEvent.VK_F7;
+            case KeyInput.KEY_F8:
+                return KeyEvent.VK_F8;
+            case KeyInput.KEY_F9:
+                return KeyEvent.VK_F9;
+            case KeyInput.KEY_F10:
+                return KeyEvent.VK_F10;
+            case KeyInput.KEY_NUMLOCK:
+                return KeyEvent.VK_NUM_LOCK;
+            case KeyInput.KEY_SCROLL:
+                return KeyEvent.VK_SCROLL_LOCK;
+            case KeyInput.KEY_NUMPAD7:
+                return KeyEvent.VK_NUMPAD7;
+            case KeyInput.KEY_NUMPAD8:
+                return KeyEvent.VK_NUMPAD8;
+            case KeyInput.KEY_NUMPAD9:
+                return KeyEvent.VK_NUMPAD9;
+            case KeyInput.KEY_SUBTRACT:
+                return KeyEvent.VK_SUBTRACT;
+            case KeyInput.KEY_NUMPAD4:
+                return KeyEvent.VK_NUMPAD4;
+            case KeyInput.KEY_NUMPAD5:
+                return KeyEvent.VK_NUMPAD5;
+            case KeyInput.KEY_NUMPAD6:
+                return KeyEvent.VK_NUMPAD6;
+            case KeyInput.KEY_ADD:
+                return KeyEvent.VK_ADD;
+            case KeyInput.KEY_NUMPAD1:
+                return KeyEvent.VK_NUMPAD1;
+            case KeyInput.KEY_NUMPAD2:
+                return KeyEvent.VK_NUMPAD2;
+            case KeyInput.KEY_NUMPAD3:
+                return KeyEvent.VK_NUMPAD3;
+            case KeyInput.KEY_NUMPAD0:
+                return KeyEvent.VK_NUMPAD0;
+            case KeyInput.KEY_DECIMAL:
+                return KeyEvent.VK_DECIMAL;
+            case KeyInput.KEY_F11:
+                return KeyEvent.VK_F11;
+            case KeyInput.KEY_F12:
+                return KeyEvent.VK_F12;
+            case KeyInput.KEY_F13:
+                return KeyEvent.VK_F13;
+            case KeyInput.KEY_F14:
+                return KeyEvent.VK_F14;
+            case KeyInput.KEY_F15:
+                return KeyEvent.VK_F15;
+            case KeyInput.KEY_KANA:
+                return KeyEvent.VK_KANA;
+            case KeyInput.KEY_CONVERT:
+                return KeyEvent.VK_CONVERT;
+            case KeyInput.KEY_NOCONVERT:
+                return KeyEvent.VK_NONCONVERT;
+            case KeyInput.KEY_NUMPADEQUALS:
+                return KeyEvent.VK_EQUALS;
+            case KeyInput.KEY_CIRCUMFLEX:
+                return KeyEvent.VK_CIRCUMFLEX;
+            case KeyInput.KEY_AT:
+                return KeyEvent.VK_AT;
+            case KeyInput.KEY_COLON:
+                return KeyEvent.VK_COLON;
+            case KeyInput.KEY_UNDERLINE:
+                return KeyEvent.VK_UNDERSCORE;
+            case KeyInput.KEY_STOP:
+                return KeyEvent.VK_STOP;
+            case KeyInput.KEY_NUMPADENTER:
+                return KeyEvent.VK_ENTER;
+            case KeyInput.KEY_RCONTROL:
+                return KeyEvent.VK_CONTROL;
+            case KeyInput.KEY_NUMPADCOMMA:
+                return KeyEvent.VK_COMMA;
+            case KeyInput.KEY_DIVIDE:
+                return KeyEvent.VK_DIVIDE;
+            case KeyInput.KEY_PAUSE:
+                return KeyEvent.VK_PAUSE;
+            case KeyInput.KEY_HOME:
+                return KeyEvent.VK_HOME;
+            case KeyInput.KEY_UP:
+                return KeyEvent.VK_UP;
+            case KeyInput.KEY_PRIOR:
+                return KeyEvent.VK_PAGE_UP;
+            case KeyInput.KEY_LEFT:
+                return KeyEvent.VK_LEFT;
+            case KeyInput.KEY_RIGHT:
+                return KeyEvent.VK_RIGHT;
+            case KeyInput.KEY_END:
+                return KeyEvent.VK_END;
+            case KeyInput.KEY_DOWN:
+                return KeyEvent.VK_DOWN;
+            case KeyInput.KEY_NEXT:
+                return KeyEvent.VK_PAGE_DOWN;
+            case KeyInput.KEY_INSERT:
+                return KeyEvent.VK_INSERT;
+            case KeyInput.KEY_DELETE:
+                return KeyEvent.VK_DELETE;
+            case KeyInput.KEY_LMENU:
+                return KeyEvent.VK_ALT; //todo: location left
+            case KeyInput.KEY_RMENU:
+                return KeyEvent.VK_ALT; //todo: location right
+        }
+        logger.warning("unsupported key:" + key);
+        return 0x10000 + key;
+    }
+
+}
Index: src/swingGui/com/jme3/swingGui/ImageGraphics.java
===================================================================
--- src/swingGui/com/jme3/swingGui/ImageGraphics.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/ImageGraphics.java	(revision 0)
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui;
+
+import java.awt.Graphics2D;
+
+import com.jme3.renderer.Renderer;
+import com.jme3.swingGui.lwjgl.LWJGLImageGraphics;
+import com.jme3.system.AppSettings;
+import com.jme3.texture.Image;
+import com.jme3.texture.Texture;
+
+
+/**
+ * This abstract class provides methods to paint on a {@link com.jme.image.Image} via the awt {@link Graphics2D}.
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public abstract class ImageGraphics extends Graphics2D {
+	
+	/**
+	 * if true, dirty region grow by 2x2 to prevent antialiasing problem
+	 */
+	private boolean expandDirtyRegion = true;
+
+    /**
+     * @param width of the image
+     * @param height of the image
+     * @param paintedMipMapCount number of mipmaps that are painted, rest is drawn by image copying, 0 for no mipmaps,
+     *                           1 for a single image painted and mipmaps copied, higher values respective
+     * @return a new instance of ImageGraphics matching the display system.
+     */
+    public static ImageGraphics createInstance( int width, int height, int paintedMipMapCount, AppSettings settings, Renderer renderer ) {
+        //this is a workaround for a proper factory method in DisplaySystem to avoid an awt dependency
+        //todo: maybe this can be done more cleanly
+
+        return new LWJGLImageGraphics( width, height, paintedMipMapCount, renderer );     
+    }
+
+    /**
+     * where painting in {@link #update()} goes to.
+     */
+    protected final com.jme3.texture.Image image;
+
+    /**
+     * Protected ctor for subclasses.
+     *
+     * @param image where painting in {@link #update()} goes to.
+     */
+    protected ImageGraphics( Image image ) {
+        this.image = image;
+    }
+
+    /**
+     * @return image where painting in {@link #update()} goes to
+     * @see #update()
+     */
+    public com.jme3.texture.Image getImage() {
+        return image;
+    }
+
+    /**
+     * Update a texture that contains the image from {@link #getImage()}. Only dirty areas are updated. The texture must
+     * have mipmapping turned off ({@link Texture#MM_NONE}). The whole area is cleaned (dirty markers removed).
+     *
+     * @param texture texture to be updated
+     */
+    public void update( Texture texture ) {
+        update( texture, true );
+    }
+
+    /**
+     * Update a texture that contains the image from {@link #getImage()}. Only dirty areas are updated. The texture must
+     * have mipmapping turned off ({@link Texture#MM_NONE}).
+     *
+     * @param texture texture to be updated
+     * @param clean   true to mark whole area as clean after updating, false to keep dirty area for updating more textures
+     */
+    public abstract void update( Texture texture, boolean clean );
+
+    /**
+     * Updates the image data.
+     *
+     * @see #getImage()
+     */
+    public abstract void update();
+
+    /**
+     * @return true if image/texture needs update
+     */
+    public abstract boolean isDirty();
+    
+    
+    /**
+     * @param expand if true, dirty region grow by 2x2 to prevent antialiasing problem
+     */
+    public void setExpandDirtyRegion(boolean expand) {
+    	expandDirtyRegion = expand;
+    }
+    
+    /**
+     * @return if true, dirty region grow by 2x2 to prevent antialiasing problem
+     */
+    public boolean isExpandDirtyRegion() {
+    	return expandDirtyRegion;
+    }
+}
Index: src/swingGui/com/jme3/swingGui/ImageGraphicsBaseImpl.java
===================================================================
--- src/swingGui/com/jme3/swingGui/ImageGraphicsBaseImpl.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/ImageGraphicsBaseImpl.java	(revision 0)
@@ -0,0 +1,781 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui;
+
+import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
+import java.awt.image.BufferedImageOp;
+import java.awt.image.RenderedImage;
+import java.awt.image.renderable.RenderableImage;
+import java.awt.Rectangle;
+import java.awt.Graphics2D;
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.FontMetrics;
+import java.awt.Shape;
+import java.awt.Composite;
+import java.awt.AlphaComposite;
+import java.awt.GraphicsConfiguration;
+import java.awt.Paint;
+import java.awt.Stroke;
+import java.awt.RenderingHints;
+import java.awt.Point;
+import java.awt.font.GlyphVector;
+import java.awt.font.FontRenderContext;
+import java.awt.geom.Rectangle2D;
+import java.awt.geom.AffineTransform;
+import java.text.AttributedCharacterIterator;
+import java.util.Map;
+import java.util.logging.Logger;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+import com.jme3.texture.Image;
+import com.jme3.util.BufferUtils;
+import com.jme3.math.FastMath;
+
+/**
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+**/
+
+public abstract class ImageGraphicsBaseImpl extends ImageGraphics {
+    protected static final Logger logger = Logger.getLogger(ImageGraphics.class.getName());
+    protected final BufferedImage awtImage;
+    public final Graphics2D delegate;
+    protected final byte[] data;
+    protected final Rectangle dirty;
+    protected final Point translation = new Point();
+    protected ByteBuffer tmp_byteBuffer;
+    protected final Color TRANSPARENT = new Color( 0, 0, 0, 0 );
+    protected final int paintedMipMapCount;
+    protected int mipMapLevel = 0;
+    protected ImageGraphicsBaseImpl mipMapChild;
+    protected boolean glTexSubImage2DSupported = true;
+    protected IntBuffer idBuff = BufferUtils.createIntBuffer(16);
+    private Rectangle imageBounds;
+    private Rectangle clip = new Rectangle();
+    private Rectangle tmp_dirty = new Rectangle();
+    protected AffineTransform tx = new AffineTransform();
+    protected float scaleX = 1;
+    protected float scaleY = 1;
+
+    protected ImageGraphicsBaseImpl( BufferedImage awtImage, byte[] data, Graphics2D delegate,
+                                com.jme3.texture.Image image, Rectangle dirty,
+                                int translationX, int translationY,
+                                float scaleX, float scaleY, int mipMapCount,
+                                ImageGraphicsBaseImpl mipMapChild, int mipMapLevel ) {
+        super( image );
+        this.awtImage = awtImage;
+        this.data = data;
+        this.delegate = delegate;
+        this.dirty = dirty;
+        translation.x = translationX;
+        translation.y = translationY;
+        this.scaleX = scaleX;
+        this.scaleY = scaleY;
+        this.paintedMipMapCount = mipMapCount;
+        this.mipMapChild = mipMapChild;
+        this.mipMapLevel = mipMapLevel;
+    }
+
+    public ImageGraphicsBaseImpl( int width, int height, int paintedMipMapCount, int mipMapLevel, float scale ) {
+
+        super( new com.jme3.texture.Image() );
+        if ( paintedMipMapCount > 1 && ( !FastMath.isPowerOfTwo( width ) || !FastMath.isPowerOfTwo( height ) ) ) {
+            throw new IllegalArgumentException( "Size must be power of 2 if mipmaps should be generated" );
+        }
+        awtImage = new BufferedImage( width, height, BufferedImage.TYPE_4BYTE_ABGR );
+        // Get a pointer to the image memory
+        ByteBuffer scratch = BufferUtils.createByteBuffer(4 * width * height );
+        tmp_byteBuffer = BufferUtils.createByteBuffer(4 * width * height );
+        data = (byte[]) awtImage.getRaster().getDataElements( 0, 0,
+                awtImage.getWidth(), awtImage.getHeight(), null );
+        scratch.clear();
+        scratch.put( data );
+        scratch.flip();
+        image.setFormat( Image.Format.RGBA8 );
+        image.setWidth( width );
+        image.setHeight( height );
+        image.setData( scratch );
+
+        delegate = (Graphics2D) awtImage.getGraphics();
+        dirty = new Rectangle( 0, 0, width, height );
+
+        this.mipMapLevel = mipMapLevel;
+        scale( scale, scale );
+        this.paintedMipMapCount = paintedMipMapCount;
+
+        setBackground( TRANSPARENT );
+    }
+
+    /**
+     * This method allows access to internal data of this class. Use for reading only. (Don't expect any
+     * direct modifications on this image to take effect immediately.)
+     * @return the BufferedImage used internally to draw at before updating the native image
+     */
+    public BufferedImage getAwtImage()
+    {
+       return awtImage;
+    }
+
+    protected Rectangle getImageBounds() {
+        if ( imageBounds == null ) {
+            imageBounds = new Rectangle( 0, 0, getImage().getWidth(), getImage().getHeight() );
+        }
+        return imageBounds;
+    }
+
+    public boolean isDirty() {
+        return !dirty.isEmpty();
+    }
+
+    public void makeDirty( int x, int y, int width, int height ) {
+        if ( width < 0 ) {
+            x = x + width;
+            width = -width;
+        }
+        if ( height < 0 ) {
+            y = y + height;
+            height = -height;
+        }
+        tmp_dirty.setBounds( x, y, width, height );
+        makeDirty( tmp_dirty );
+    }
+
+    private void makeDirty( Rectangle rectangle ) {
+        synchronized ( dirty ) {
+
+            getClipBounds( clip );
+
+            //debug-:
+//            final StackTraceElement[] stackTrace = new Exception().getStackTrace();
+//            for ( int i=0; i < stackTrace.length; i++ )
+//            {
+//                final String methodName = stackTrace[i].getMethodName();
+//                if ( !"makeDirty".equals( methodName ) )
+//                {
+//                    logger.info( methodName +"["+ stackTrace[i].getLineNumber() + "]" );
+//                    break;
+//                }
+//            }
+            Rectangle2D.intersect( clip, rectangle, rectangle );
+            if ( !rectangle.isEmpty() ) {
+                rectangle.x *= scaleX;
+                rectangle.y *= scaleY;
+                rectangle.width *= scaleX;
+                rectangle.height *= scaleY;
+                rectangle.translate( translation.x, translation.y );
+                Rectangle2D.intersect( rectangle, getImageBounds(), rectangle );
+                if ( !rectangle.isEmpty() ) {
+                    if ( !dirty.isEmpty() ) {
+                        dirty.add( rectangle );
+                    }
+                    else {
+                        dirty.setBounds( rectangle );
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * todo: don't be lazy - compute the actual area!
+     */
+    private void makeDirty() {
+        makeDirty( 0, 0, getImage().getWidth(), getImage().getHeight() );
+    }
+
+    public Color getColor() {
+        return delegate.getColor();
+    }
+
+    public void setColor( Color c ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setColor( c );
+        }
+        delegate.setColor( c );
+    }
+
+    public void setPaintMode() {
+        if ( mipMapChild != null ) {
+            mipMapChild.setPaintMode();
+        }
+        delegate.setPaintMode();
+    }
+
+    public void setXORMode( Color c1 ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setXORMode( c1 );
+        }
+        delegate.setXORMode( c1 );
+    }
+
+    public Font getFont() {
+        return delegate.getFont();
+    }
+
+    public void setFont( Font font ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setFont( font );
+        }
+        delegate.setFont( font );
+    }
+
+    public FontMetrics getFontMetrics( Font f ) {
+        return delegate.getFontMetrics( f );
+    }
+
+    public Rectangle getClipBounds() {
+        return delegate.getClipBounds();
+    }
+
+    public void clipRect( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.clipRect( x, y, width, height );
+        }
+        delegate.clipRect( x, y, width, height );
+    }
+
+    public void setClip( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setClip( x, y, width, height );
+        }
+        delegate.setClip( x, y, width, height );
+    }
+
+    public Shape getClip() {
+        return delegate.getClip();
+    }
+
+    public void setClip( Shape clip ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setClip( clip );
+        }
+        delegate.setClip( clip );
+    }
+
+    public void copyArea( int x, int y, int width, int height, int dx, int dy ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.copyArea( x, y, width, height, dx, dy );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x + dx, y + dy, width, height );
+            delegate.copyArea( x, y, width, height, dx, dy );
+        }
+    }
+
+    public void drawLine( int x1, int y1, int x2, int y2 ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawLine( x1, y1, x2, y2 );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x1, y1, x2 - x1, y2 - y1 );
+            delegate.drawLine( x1, y1, x2, y2 );
+        }
+    }
+
+    public void fillRect( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fillRect( x, y, width, height );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.fillRect( x, y, width, height );
+        }
+    }
+
+    public void clearRect( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.clearRect( x, y, width, height );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            //works in JDK1.5:
+//            delegate.clearRect( x, y, width, height );
+
+            //fix for bug in JDK1.4:
+            Color color = delegate.getColor();
+            delegate.setColor( delegate.getBackground() );
+            Composite composite = delegate.getComposite();
+            delegate.setComposite( AlphaComposite.Clear );
+            delegate.fillRect( x, y, width, height );
+            delegate.setComposite( composite );
+            delegate.setColor( color );
+        }
+    }
+
+    public void drawRoundRect( int x, int y, int width, int height, int arcWidth, int arcHeight ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawRoundRect( x, y, width, height, arcWidth, arcHeight );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.drawRoundRect( x, y, width, height, arcWidth, arcHeight );
+        }
+    }
+
+    public void fillRoundRect( int x, int y, int width, int height, int arcWidth, int arcHeight ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fillRoundRect( x, y, width, height, arcWidth, arcHeight );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.fillRoundRect( x, y, width, height, arcWidth, arcHeight );
+        }
+    }
+
+    public void drawOval( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawOval( x, y, width, height );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.drawOval( x, y, width, height );
+        }
+    }
+
+    public void fillOval( int x, int y, int width, int height ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fillOval( x, y, width, height );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.fillOval( x, y, width, height );
+        }
+    }
+
+    public void drawArc( int x, int y, int width, int height, int startAngle, int arcAngle ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawArc( x, y, width, height, startAngle, arcAngle );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.drawArc( x, y, width, height, startAngle, arcAngle );
+        }
+    }
+
+    public void fillArc( int x, int y, int width, int height, int startAngle, int arcAngle ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fillArc( x, y, width, height, startAngle, arcAngle );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            delegate.fillArc( x, y, width, height, startAngle, arcAngle );
+        }
+    }
+
+    public void drawPolyline( int[] xPoints, int[] yPoints, int nPoints ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawPolyline( xPoints, yPoints, nPoints );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawPolyline( xPoints, yPoints, nPoints );
+        }
+    }
+
+    public void drawPolygon( int[] xPoints, int[] yPoints, int nPoints ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawPolygon( xPoints, yPoints, nPoints );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawPolygon( xPoints, yPoints, nPoints );
+        }
+    }
+
+    public void fillPolygon( int[] xPoints, int[] yPoints, int nPoints ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fillPolygon( xPoints, yPoints, nPoints );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.fillPolygon( xPoints, yPoints, nPoints );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int x, int y, ImageObserver observer ) {
+        makeDirty( x, y, img.getWidth( observer ), img.getHeight( observer ) );
+        synchronized ( dirty ) {
+            if ( mipMapChild != null ) {
+                mipMapChild.drawImage( img, x, y, observer );
+            }
+            return delegate.drawImage( img, x, y, observer );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int x, int y, int width, int height, ImageObserver observer ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, x, y, width, height, observer );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            return delegate.drawImage( img, x, y, width, height, observer );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int x, int y, Color bgcolor, ImageObserver observer ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, x, y, bgcolor, observer );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, img.getWidth( observer ), img.getHeight( observer ) );
+            return delegate.drawImage( img, x, y, bgcolor, observer );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, x, y, width, height, bgcolor, observer );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, width, height );
+            return delegate.drawImage( img, x, y, width, height, bgcolor, observer );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer );
+        }
+        synchronized ( dirty ) {
+            makeDirty( dx1, dy1, dx2 - dx1, dy2 - dy1 );
+            return delegate.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, observer );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer );
+        }
+        synchronized ( dirty ) {
+            makeDirty( dx1, dy1, dx2 - dx1, dy2 - dy1 );
+            return delegate.drawImage( img, dx1, dy1, dx2, dy2, sx1, sy1, sx2, sy2, bgcolor, observer );
+        }
+    }
+
+    public void dispose() {
+        if ( mipMapChild != null ) {
+            mipMapChild.dispose();
+        }
+        delegate.dispose();
+    }
+
+    public void draw( Shape s ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.draw( s );
+        }
+        synchronized ( dirty ) {
+            makeDirty( s.getBounds() );
+            delegate.draw( s );
+        }
+    }
+
+    public boolean drawImage( java.awt.Image img, AffineTransform xform, ImageObserver obs ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, xform, obs );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            return delegate.drawImage( img, xform, obs );
+        }
+    }
+
+    public void drawImage( BufferedImage img, BufferedImageOp op, int x, int y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawImage( img, op, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty( x, y, img.getWidth( null ), img.getHeight( null ) );
+            delegate.drawImage( img, op, x, y );
+        }
+    }
+
+    public void drawRenderedImage( RenderedImage img, AffineTransform xform ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawRenderedImage( img, xform );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawRenderedImage( img, xform );
+        }
+    }
+
+    public void drawRenderableImage( RenderableImage img, AffineTransform xform ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawRenderableImage( img, xform );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawRenderableImage( img, xform );
+        }
+    }
+
+    public void drawString( String str, int x, int y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawString( str, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawString( str, x, y );
+        }
+    }
+
+    public void drawString( String s, float x, float y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawString( s, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawString( s, x, y );
+        }
+    }
+
+    public void drawString( AttributedCharacterIterator iterator, int x, int y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawString( iterator, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawString( iterator, x, y );
+        }
+    }
+
+    public void drawString( AttributedCharacterIterator iterator, float x, float y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawString( iterator, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawString( iterator, x, y );
+        }
+    }
+
+    public void drawGlyphVector( GlyphVector g, float x, float y ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.drawGlyphVector( g, x, y );
+        }
+        synchronized ( dirty ) {
+            makeDirty();
+            delegate.drawGlyphVector( g, x, y );
+        }
+    }
+
+    public void fill( Shape s ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.fill( s );
+        }
+        synchronized ( dirty ) {
+            makeDirty( s.getBounds() );
+            delegate.fill( s );
+        }
+    }
+
+    public boolean hit( Rectangle rect, Shape s, boolean onStroke ) {
+        return delegate.hit( rect, s, onStroke );
+    }
+
+    public GraphicsConfiguration getDeviceConfiguration() {
+        return delegate.getDeviceConfiguration();
+    }
+
+    public void setComposite( Composite comp ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setComposite( comp );
+        }
+        delegate.setComposite( comp );
+    }
+
+    public void setPaint( Paint paint ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setPaint( paint );
+        }
+        delegate.setPaint( paint );
+    }
+
+    public void setStroke( Stroke s ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setStroke( s );
+        }
+        delegate.setStroke( s );
+    }
+
+    public void setRenderingHint( RenderingHints.Key hintKey, Object hintValue ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setRenderingHint( hintKey, hintValue );
+        }
+        delegate.setRenderingHint( hintKey, hintValue );
+    }
+
+    public Object getRenderingHint( RenderingHints.Key hintKey ) {
+        return delegate.getRenderingHint( hintKey );
+    }
+
+    public void setRenderingHints( Map<?,?> hints ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setRenderingHints( hints );
+        }
+        delegate.setRenderingHints( hints );
+    }
+
+    public void addRenderingHints( Map<?,?> hints ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.addRenderingHints( hints );
+        }
+        delegate.addRenderingHints( hints );
+    }
+
+    public RenderingHints getRenderingHints() {
+        return delegate.getRenderingHints();
+    }
+
+    public void translate( int x, int y ) {
+        translation.x += x * scaleX;
+        translation.y += y * scaleY;
+        if ( mipMapChild != null ) {
+            mipMapChild.translate( x, y );
+        }
+        delegate.translate( x, y );
+    }
+
+    public void translate( double tx, double ty ) {
+        translation.x += tx * scaleX;
+        translation.y += ty * scaleY;
+        if ( mipMapChild != null ) {
+            mipMapChild.translate( tx, ty );
+        }
+        delegate.translate( tx, ty );
+    }
+
+    public void rotate( double theta ) {
+        throw new UnsupportedOperationException();
+//        delegate.rotate( theta );
+    }
+
+    public void rotate( double theta, double x, double y ) {
+        throw new UnsupportedOperationException();
+//        delegate.rotate( theta, x, y );
+    }
+
+    public void scale( double sx, double sy ) {
+        scaleX *= sx;
+        scaleY *= sy;
+        if ( mipMapChild != null ) {
+            mipMapChild.scale( sx, sy );
+        }
+        delegate.scale( sx, sy );
+    }
+
+    public void shear( double shx, double shy ) {
+        throw new UnsupportedOperationException();
+//        delegate.shear( shx, shy );
+    }
+
+    public void transform( AffineTransform Tx ) {
+        tx.setTransform(Tx);
+        delegate.transform( Tx );
+    }
+
+    public void setTransform( AffineTransform Tx ) {
+        tx.setTransform(Tx);
+        delegate.setTransform( Tx );
+    }
+
+    public AffineTransform getTransform() {
+        return delegate.getTransform();
+    }
+
+    public Paint getPaint() {
+        return delegate.getPaint();
+    }
+
+    public Composite getComposite() {
+        return delegate.getComposite();
+    }
+
+    public void setBackground( Color color ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.setBackground( color );
+        }
+        delegate.setBackground( color );
+    }
+
+    public Color getBackground() {
+        return delegate.getBackground();
+    }
+
+    public Stroke getStroke() {
+        return delegate.getStroke();
+    }
+
+    public void clip( Shape s ) {
+        if ( mipMapChild != null ) {
+            mipMapChild.clip( s );
+        }
+        delegate.clip( s );
+    }
+
+    public FontRenderContext getFontRenderContext() {
+        return delegate.getFontRenderContext();
+    }
+
+    public void update() {
+        synchronized (dirty) {
+            if (dirty == null) {
+                awtImage.getRaster().getDataElements(0, 0, awtImage.getWidth(),
+                        awtImage.getHeight(), data);
+                ByteBuffer scratch = getImage().getData(0);
+                scratch.clear();
+                scratch.put(data);
+                scratch.flip();
+            } else {
+                awtImage.getRaster().getDataElements(dirty.x, dirty.y,
+                        dirty.width, dirty.height, data);
+                ByteBuffer scratch = getImage().getData(0);
+                int pixLen = awtImage.getRaster().getNumDataElements();
+                for (int dirtyRow = 0; dirtyRow < dirty.height; ++dirtyRow) {
+                    scratch
+                            .position(((image.getWidth() * (dirty.y + dirtyRow)) + dirty.x)
+                                    * pixLen);
+                    scratch.put(data, dirty.width * dirtyRow * pixLen,
+                            dirty.width * pixLen);
+                }
+            }
+        }
+    }
+}
+
+/*
+ * $Log$
+ */
+
Index: src/swingGui/com/jme3/swingGui/JMEDesktop.java
===================================================================
--- src/swingGui/com/jme3/swingGui/JMEDesktop.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/JMEDesktop.java	(revision 0)
@@ -0,0 +1,1406 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui;
+
+import java.awt.AWTEvent;
+import java.awt.BorderLayout;
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Dimension;
+import java.awt.Frame;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.KeyboardFocusManager;
+import java.awt.Point;
+import java.awt.Rectangle;
+import java.awt.RenderingHints;
+import java.awt.event.ContainerEvent;
+import java.awt.event.ContainerListener;
+import java.awt.event.FocusEvent;
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseWheelEvent;
+import java.beans.PropertyVetoException;
+import java.lang.reflect.InvocationTargetException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import javax.swing.JComponent;
+import javax.swing.JDesktopPane;
+import javax.swing.JInternalFrame;
+import javax.swing.JPanel;
+import javax.swing.JRootPane;
+import javax.swing.JScrollPane;
+import javax.swing.JTabbedPane;
+import javax.swing.JViewport;
+import javax.swing.Popup;
+import javax.swing.PopupFactory;
+import javax.swing.RepaintManager;
+import javax.swing.SwingUtilities;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+import javax.swing.plaf.basic.BasicInternalFrameUI;
+
+import com.jme3.asset.AssetManager;
+import com.jme3.input.InputManager;
+import com.jme3.input.KeyInput;
+import com.jme3.input.RawInputListener;
+import com.jme3.input.event.JoyAxisEvent;
+import com.jme3.input.event.JoyButtonEvent;
+import com.jme3.input.event.KeyInputEvent;
+import com.jme3.input.event.MouseButtonEvent;
+import com.jme3.input.event.MouseMotionEvent;
+import com.jme3.input.event.TouchEvent;
+import com.jme3.material.Material;
+import com.jme3.material.TechniqueDef.LightMode;
+import com.jme3.math.Ray;
+import com.jme3.math.Vector2f;
+import com.jme3.math.Vector3f;
+import com.jme3.renderer.RenderManager;
+import com.jme3.scene.Geometry;
+import com.jme3.scene.Node;
+import com.jme3.scene.shape.Quad;
+import com.jme3.swingGui.dnd.JMEDragAndDrop;
+import com.jme3.system.AppSettings;
+import com.jme3.system.JmeSystem;
+import com.jme3.texture.Texture;
+import com.jme3.texture.Texture2D;
+
+/**
+ * A quad that displays a {@link JDesktopPane} as texture. It also converts jME mouse and keyboard events to Swing
+ * events. The latter does work for ortho mode only. There are some issues with using multiple of this desktops.
+ * <p>
+ * Notes
+ * <ul>
+ * <li> Only access the Swing UI from the Swing event dispatch thread! See {@link SwingUtilities#invokeLater}
+ * and <a href="http://java.sun.com/docs/books/tutorial/uiswing/concurrency/index.html">Swing tutorial</a> for details.</li>
+ * <li>If you would like to change the L&F take into account that PropertiesDialog and PropertiesDialog2 change
+ * the L&F setting upon invocation (you can e.g. change the L&F after the dialog).</li>
+ * </ul>
+ *
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ *
+ * @see ImageGraphics
+ */
+public class JMEDesktop extends Geometry {
+    private static final Logger logger = Logger.getLogger(JMEDesktop.class
+            .getName());
+    
+    private static final long serialVersionUID = 1L;
+    private ImageGraphics graphics;
+    private JDesktopPane desktop;
+    private Texture texture;
+    private boolean initialized;
+    private int width;
+    private int height;
+
+    private boolean showingJFrame = false;
+    private final Frame awtWindow;
+    private int desktopWidth;
+    private int desktopHeight;
+    private static final int DOUBLE_CLICK_TIME = 300;
+    private RawInputListener rawInputListener; // The Listener, which handles the Events;
+    private InputManager inputManager; // The Parent InputManager
+    private JMEDragAndDrop dragAndDropSupport;
+    private AppSettings settings;
+    private RenderManager renderer;
+    private boolean disposing = false;
+
+    /**
+     * @return JMEDragAndDrop used for this desktop
+     */
+    public JMEDragAndDrop getDragAndDropSupport() {
+        return dragAndDropSupport;
+    }
+
+    /**
+     * @param dragAndDropSupport JMEDragAndDrop to be used for this desktop
+     * @see JMEDragAndDrop#setDesktop(JMEDesktop)
+     */
+    public void setDragAndDropSupport( JMEDragAndDrop dragAndDropSupport ) {
+        this.dragAndDropSupport = dragAndDropSupport;
+    }
+
+    /**
+     * @see #setShowingJFrame
+     * @return true if frame is displayed
+     */
+    public boolean isShowingJFrame() {
+        return showingJFrame;
+    }
+
+    /**
+     * @param showingJFrame true to display the desktop in a JFrame instead on this quad.
+     * @deprecated for debuggin only
+     */
+    public void setShowingJFrame( boolean showingJFrame ) {
+        this.showingJFrame = showingJFrame;
+        awtWindow.setVisible( showingJFrame );
+        awtWindow.repaint();
+    }
+
+    /**
+     * Allows to disable input for the whole desktop and to add custom input actions.
+     *
+     * @return this desktops input hander for input bindings
+     * @see #getXUpdateAction()
+     * @see #getYUpdateAction()
+     * @see #getWheelUpdateAction()
+     * @see #getButtonUpdateAction(int)
+     * @see #getKeyUpdateAction()
+     */
+    public InputManager getInputManager() {
+        return inputManager;
+    }
+
+    /**
+     * Create a quad with a Swing-Texture. Creates the quad and the JFrame but do not setup the rest.
+     * Call {@link #setup(int, int, boolean, InputManager)} to finish setup.
+     *
+     * @param name name of this desktop
+     */
+    private JMEDesktop( String name ) {
+        super(name);
+/*
+Quad quad = new Quad(2,2)
+{
+  @Override
+  public void updateGeometry(float x, float y)
+  {
+    this.updateGeometry(x,y,false);
+  } 
+  @Override
+  public void updateGeometry(float x, float y, boolean flip)
+  {
+    super.updateGeometry(x,y,flip);
+
+        setBuffer(Type.Position, 3, new float[]{0,      0,      0,
+                                                width,  0,      0,
+                                                width,  height, 0,
+                                                0,      height, 0
+                                                });
+//    setBuffer(Type.Position, 3, new float[]{(-width / 2f),(height / 2f),0,   (-width / 2f),(-height / 2f),0,   (width / 2f),(-height / 2f),0,   (width / 2f),(height / 2f),0 });
+  } 
+};
+*/
+//setMesh(quad);
+setMesh(new Quad());
+
+        awtWindow = new Frame() {
+            private static final long serialVersionUID = 1L;
+            public boolean isShowing() {
+                return true;
+            }
+
+            public boolean isVisible() {
+//                if ( new Throwable().getStackTrace()[1].getMethodName().startsWith( "requestFocus" ) ) {
+//                    logger.info( "requestFocus" );
+//                }
+
+                if ( awtWindow.isFocusableWindow()
+                        && new Throwable().getStackTrace()[1].getMethodName().startsWith( "requestFocus" ) ) {
+                    return false;
+                }
+                return initialized || super.isVisible();
+            }
+
+            public Graphics getGraphics() {
+                if ( !showingJFrame ) {
+                    return graphics == null ? super.getGraphics() : graphics.create();
+                }
+                
+                return super.getGraphics();
+            }
+
+            public boolean isFocused() {
+                return true;
+            }
+        };
+        awtWindow.setFocusableWindowState( false );
+        Container contentPane = awtWindow;
+        awtWindow.setUndecorated( true );
+        dontDrawBackground( contentPane );
+//            ( (JComponent) contentPane ).setOpaque( false );
+
+        desktop = new JDesktopPane() {
+            private static final long serialVersionUID = 1L;
+            public void paint( Graphics g ) {
+                if ( !isShowingJFrame() ) {
+                    g.clearRect( 0, 0, getWidth(), getHeight() );
+                }
+                super.paint( g );
+            }
+
+            public boolean isOptimizedDrawingEnabled() {
+                return false;
+            }
+        };
+
+        new ScrollPaneRepaintFixListener().addTo( desktop );
+
+
+        final Color transparent = new Color( 0, 0, 0, 0 );
+        desktop.setBackground( transparent );
+        desktop.setFocusable( true );
+        desktop.addMouseListener( new MouseAdapter() {
+            public void mousePressed( MouseEvent e ) {
+                desktop.requestFocusInWindow();
+            }
+        } );
+
+        // this internal frame is a workaround for key binding problems in JDK1.5
+        // todo: this workaround does not seem to work on mac
+        if ( System.getProperty( "os.name" ).toLowerCase().indexOf( "mac" ) < 0 ) {
+            final JInternalFrame internalFrame = new JInternalFrame();
+            internalFrame.setUI( new BasicInternalFrameUI( internalFrame ) {
+                protected void installComponents() {
+                }
+            } );
+            internalFrame.setOpaque( false );
+            internalFrame.setBackground( null );
+            internalFrame.getContentPane().setLayout( new BorderLayout() );
+            internalFrame.getContentPane().add( desktop, BorderLayout.CENTER );
+            internalFrame.setVisible( true );
+            internalFrame.setBorder( null );
+            contentPane.add( internalFrame );
+        }
+        else {
+            // this would have suited for JDK1.4:
+            contentPane.add( desktop, BorderLayout.CENTER );
+        }
+
+        awtWindow.pack();
+
+        RepaintManager.currentManager( null ).setDoubleBufferingEnabled( false );
+    }
+
+    /**
+     * Create a quad with a Swing-Texture.
+     * Note that for the texture a width and height that is a power of 2 is used if the graphics card does
+     * not support the specified size for textures. E.g. this results in a 1024x512
+     * texture for a 640x480 desktop (consider using a 512x480 desktop in that case).
+     *
+     * @param name               name of the spatial
+     * @param width              desktop width
+     * @param height             desktop height
+     * @param inputHandlerParent InputManager where the InputListener of this desktop should be added as subhandler.
+     * @see #getInputManager()
+     */
+    public JMEDesktop( String name, final int width, final int height, InputManager inputHandlerParent , AppSettings settings, RenderManager renderer) {
+        this( name, width, height, false, inputHandlerParent, settings, renderer );
+    }
+
+    /**
+     * Create a quad with a Swing-Texture.
+     * Note that for the texture a width and height that is a power of 2 is used if the graphics card does
+     * not support the specified size for textures or mipMapping is true. E.g. this results in a 1024x512
+     * texture for a 640x480 desktop (consider using a 512x480 desktop in that case).
+     *
+     * @param name               name of the spatial
+     * @param width              desktop width
+     * @param height             desktop hieght
+     * @param mipMapping         true to compute mipmaps for the desktop (not recommended), false for creating
+     *                           a single image texture
+     * @param inputHandlerParent InputManager where the InputListener of this desktop should be added as subhandler.
+     * @see #getInputManager()
+     */
+    public JMEDesktop( String name, final int width, final int height, boolean mipMapping, InputManager inputHandlerParent, AppSettings settings, RenderManager renderer ) {
+        this( name, width, height, 1280, 720, mipMapping, inputHandlerParent, settings, renderer );
+    }
+
+    /**
+     * Create a quad with a Swing-Texture.
+     * Note that for the texture a width and height that is a power of 2 is used if the graphics card does
+     * not support the specified size for textures or mipMapping is true. E.g. this results in a 1024x512
+     * texture for a 640x480 desktop (consider using a 512x480 desktop in that case).
+     *
+     * @param name               name of the spatial
+     * @param width              desktop width
+     * @param height             desktop hieght
+     * @param scaleFromWidth     default width, that will be scaled
+     * @param scaleFromHeight    default height, that will be scaled
+     * @param mipMapping         true to compute mipmaps for the desktop (not recommended), false for creating
+     *                           a single image texture
+     * @param inputHandlerParent InputManager where the InputListener of this desktop should be added as subhandler.
+     * @see #getInputManager()
+     */
+    public JMEDesktop( String name, final int width, final int height, int scaleFromWidth, int scaleFromHeight, boolean mipMapping, InputManager inputHandlerParent, AppSettings settings, RenderManager renderer ) {
+        this( name );
+        this.renderer = renderer;
+        setup( width, height, scaleFromWidth, scaleFromHeight, mipMapping, inputHandlerParent, settings );
+    }
+
+    /**
+     * Set up the desktop quad - may be called only once.
+     * Note that for the texture a width and height that is a power of 2 is used if the graphics card does
+     * not support the specified size for textures or mipMapping is true. E.g. this results in a 1024x512
+     * texture for a 640x480 desktop (consider using a 512x480 desktop in that case).
+     *
+     * @param width              desktop width
+     * @param height             desktop hieght
+     * @param mipMapping         true to compute mipmaps for the desktop (not recommended), false for creating
+     *                           a single image texture
+     * @param inputHandlerParent InputManager where the InputListener of this desktop should be added as subhandler,
+     * @see #getInputManager()
+     */
+    private void setup( int width, int height, int unscaledWidth, int unscaledHeight, boolean mipMapping, InputManager inputHandlerParent, AppSettings settings ) {
+//        reconstruct( null, null, null, null );
+        if ( inputHandlerParent == null ) {
+            throw new IllegalStateException( "InputManager must not be null!" );
+        }
+
+        if ( initialized ) {
+            throw new IllegalStateException( "may be called only once" );
+        }
+        inputManager = inputHandlerParent;
+        this.settings = settings;
+        initInputActions(inputHandlerParent);
+        ((Quad)getMesh()).updateGeometry( powerOf2SizeIfNeeded( unscaledWidth, mipMapping ), powerOf2SizeIfNeeded( unscaledHeight, mipMapping ), true );
+
+        this.width = powerOf2SizeIfNeeded( unscaledWidth, mipMapping );
+        this.height = powerOf2SizeIfNeeded( unscaledHeight, mipMapping );
+//        setModelBound( new BoundingBox() );
+//        updateModelBound();
+
+        desktop.setPreferredSize( new Dimension( unscaledWidth, unscaledHeight ) );
+        desktopWidth = unscaledWidth;
+        desktopHeight = unscaledHeight;
+        awtWindow.pack();
+
+
+//        TextureState ts = DisplaySystem.getDisplaySystem().getRenderer().createTextureState();
+//        ts.setCorrectionType( TextureState.CorrectionType.Perspective );
+        texture = new Texture2D();
+        texture.setMagFilter( Texture.MagFilter.Bilinear );
+        texture.setMinFilter( mipMapping ? Texture.MinFilter.Trilinear : Texture.MinFilter.BilinearNoMipMaps );
+        texture.setWrap( Texture.WrapMode.Repeat );
+
+        graphics = ImageGraphics.createInstance( this.width, this.height, mipMapping ? 2 : 0 , settings, renderer.getRenderer());
+        enableAntiAlias( graphics );
+        graphics.translate( ( this.width - unscaledWidth ) * 0.5f, ( this.height - unscaledHeight ) * 0.5f );
+        texture.setImage( graphics.getImage() );
+
+//        texture.setScale( new Vector3f( 1, -1, 1 ) );
+//        ts.setTexture( texture );
+//        this.setRenderState( ts );
+
+
+        AssetManager assetManager = JmeSystem.newAssetManager(Thread.currentThread().getContextClassLoader().getResource("com/jme3/asset/Desktop.cfg"));
+        Material mat = new Material(assetManager, "Common/MatDefs/Misc/Unshaded.j3md");
+mat.setTransparent(true);
+mat.getAdditionalRenderState().setBlendMode(com.jme3.material.RenderState.BlendMode.Alpha);
+        mat.selectTechnique("Default",renderer);
+        mat.getActiveTechnique().getDef().setLightMode(LightMode.Disable);
+        mat.setTexture("m_ColorMap", texture);
+        setMaterial(mat);
+setQueueBucket(com.jme3.renderer.queue.RenderQueue.Bucket.Gui);
+//setQueueBucket(com.jme3.renderer.queue.RenderQueue.Bucket.Transparent);
+//getLocalScale().set(new Vector3f(0.5f,0.5f,0.5f)); //Nur zum Testen
+
+
+/*
+        BlendState alpha = DisplaySystem.getDisplaySystem().getRenderer().createBlendState();
+        alpha.setEnabled( true );
+        alpha.setBlendEnabled( true );
+        alpha.setSourceFunction( BlendState.SourceFunction.SourceAlpha );
+        alpha.setDestinationFunction( BlendState.DestinationFunction.OneMinusSourceAlpha );
+        alpha.setTestEnabled( true );
+        alpha.setTestFunction( BlendState.TestFunction.GreaterThan );
+        this.setRenderState( alpha );
+*/
+
+//        Toolkit.getDefaultToolkit().addAWTEventListener( new AWTEventListener() {
+//            public void eventDispatched( AWTEvent event ) {
+//                if ( isShowingJFrame() ) {
+//                    logger.info( event );
+//                }
+//            }
+//        }, 0xFFFFFFFFFFFFFFFFl );
+
+
+        if ( desktopsUsed == 0 ) {
+            PopupFactory.setSharedInstance( new MyPopupFactory() );
+        }
+        desktopsUsed++;
+
+        SwingUtilities.invokeLater( new Runnable() {
+            public void run() {
+                if (!disposing)JMEDesktop.this.setFocusOwner( desktop );
+            }
+        } );
+
+        initialized = true;
+
+        setSynchronizingThreadsOnUpdate( true );
+        setLocalScale(((float)width/(float)unscaledWidth),((float)height/(float)unscaledHeight),1.0f);
+    }
+
+  private void initInputActions(InputManager manager)
+  {
+    inputManager = manager;
+    rawInputListener = new RawInputListener()
+    {
+      public void beginInput() {}
+      public void endInput() {}
+      public void onJoyAxisEvent(JoyAxisEvent evt) {}
+      public void onJoyButtonEvent(JoyButtonEvent evt) {}
+      public void onMouseMotionEvent(MouseMotionEvent evt)
+      {
+        onMove(evt.getDX(), evt.getDY(), evt.getX(), evt.getY());
+        onWheel(evt.getDeltaWheel(), evt.getX(), evt.getY());
+      }
+      public void onMouseButtonEvent(MouseButtonEvent evt)
+      {
+            setButtonDown(evt.getButtonIndex(), evt.isPressed());
+            onButton( evt.getButtonIndex(), evt.isPressed(), lastXin, lastYin );
+      }
+      public void onKeyEvent(KeyInputEvent evt)
+      {
+        setKeyDown(evt.getKeyCode(), evt.isPressed());
+        onKey( evt.getKeyChar(), evt.getKeyCode(), evt.isPressed());
+      }
+	@Override
+	public void onTouchEvent(TouchEvent evt) {
+		// TODO Auto-generated method stub
+		
+	}
+    };
+    manager.addRawInputListener(rawInputListener);
+  }
+
+    private static int desktopsUsed = 0;
+
+
+    //todo: reuse the runnables
+    //todo: possibly reuse events, too?
+
+    public void onKey( final char character, final int keyCode, final boolean pressed ) {
+        try {
+            SwingUtilities.invokeAndWait( new Runnable() {
+                public void run() {
+                    if (!disposing)sendAWTKeyEvent( keyCode, pressed, character );
+                }
+            } );
+        } catch ( InterruptedException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onKey(character, keyCode, pressed)", "Exception", e);
+        } catch ( InvocationTargetException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onKey(character, keyCode, pressed)", "Exception", e);
+        }
+    }
+
+    public void onButton( final int swingButton, final boolean pressed, final int x, final int y ) {
+        convert( x, y, location );
+        final int awtX = (int) location.x;
+        final int awtY = (int) location.y;
+        final int awtSwingButton = convertButton(swingButton);
+        try {
+            SwingUtilities.invokeAndWait( new Runnable() {
+                public void run() {
+                    if (!disposing)sendAWTMouseEvent( awtX, awtY, pressed, awtSwingButton );
+                }
+            } );
+        } catch ( InterruptedException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onButton(swingButton, pressed, x, y)", "Exception", e);
+        } catch ( InvocationTargetException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onButton(swingButton, pressed, x, y)", "Exception", e);
+        }
+    }
+
+    public void onWheel( final int wheelDelta, final int x, final int y ) {
+        convert( x, y, location );
+        final int awtX = (int) location.x;
+        final int awtY = (int) location.y;
+        try {
+            SwingUtilities.invokeAndWait( new Runnable() {
+                public void run() {
+                    if (!disposing)sendAWTWheelEvent( wheelDelta, awtX, awtY );
+                }
+            } );
+        } catch ( InterruptedException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onWheel(wheelDelta, x, y)", "Exception", e);
+        } catch ( InvocationTargetException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onWheel(wheelDelta, x, y)", "Exception", e);
+        }
+    }
+
+    public void onMove( int xDelta, int yDelta, final int newX, final int newY ) {
+        convert( newX, newY, location );
+        final int awtX = (int) location.x;
+        final int awtY = (int) location.y;
+        try {
+            SwingUtilities.invokeAndWait( new Runnable() {
+                public void run() {
+                    if (!disposing)sendAWTMouseEvent( awtX, awtY, false, MouseEvent.NOBUTTON );
+                }
+            } );
+        } catch ( InterruptedException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onMove(xDelta, yDelta, newX, newY)", "Exception", e);
+        } catch ( InvocationTargetException e ) {
+            logger.logp(Level.SEVERE, this.getClass().toString(),
+                    "onMove(xDelta, yDelta, newX, newY)", "Exception", e);
+        }
+    }
+
+    private boolean synchronizingThreadsOnUpdate;
+
+    /**
+     * @return true if update and swing thread should be synchronized (avoids flickering, eats some performance)
+     */
+    public boolean isSynchronizingThreadsOnUpdate() {
+        return synchronizingThreadsOnUpdate;
+    }
+
+    /**
+     * Choose if update and swing thread should be synchronized (avoids flickering, eats some performance)
+     *
+     * @param synchronizingThreadsOnUpdate true to synchronize
+     */
+    public void setSynchronizingThreadsOnUpdate( boolean synchronizingThreadsOnUpdate ) {
+        if ( this.synchronizingThreadsOnUpdate != synchronizingThreadsOnUpdate ) {
+            this.synchronizingThreadsOnUpdate = synchronizingThreadsOnUpdate;
+        }
+    }
+
+    private void enableAntiAlias( Graphics2D graphics ) {
+        RenderingHints hints = graphics.getRenderingHints();
+        if ( hints == null ) {
+            hints = new RenderingHints( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
+        }
+        else {
+            hints.put( RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON );
+        }
+        graphics.setRenderingHints( hints );
+    }
+
+    public Vector2f getMousePosition()
+    {
+      return new Vector2f((float)lastXin, (float)lastYin);
+    }
+
+    private static class LightWeightPopup extends Popup {
+        private static final Integer INTEGER_MAX_VALUE = Integer.MAX_VALUE;
+
+        public LightWeightPopup( JComponent desktop ) {
+            this.desktop = desktop;
+            new ScrollPaneRepaintFixListener().addTo( panel );
+        }
+
+        private final JComponent desktop;
+
+        JPanel panel = new JPanel( new BorderLayout() );
+
+        public void adjust( Component owner, Component contents, int x, int y ) {
+            panel.setVisible( false );
+            desktop.add( panel, INTEGER_MAX_VALUE );
+            panel.removeAll();
+            panel.add( contents, BorderLayout.CENTER );
+            if ( contents instanceof JComponent ) {
+                JComponent jComponent = (JComponent) contents;
+                jComponent.setDoubleBuffered( false );
+            }
+            panel.setSize( panel.getPreferredSize() );
+            y = Math.min( y, desktop.getHeight() - panel.getHeight() );
+            x = Math.min( x, desktop.getWidth() - panel.getWidth() );
+            panel.setLocation( x, y );
+            contents.invalidate();
+            panel.validate();
+        }
+
+        public void show() {
+            panel.setVisible( true );
+        }
+
+        public void hide() {
+            Rectangle bounds = panel.getBounds();
+            desktop.remove( panel );
+            desktop.repaint( bounds );
+        }
+    }
+
+    private void sendAWTKeyEvent( int keyCode, boolean pressed, char character ) {
+        keyCode = AWTKeyInput.toAWTCode( keyCode );
+        if ( keyCode != 0 ) {
+            Component focusOwner = getFocusOwner();
+            if ( focusOwner == null ) {
+                focusOwner = desktop;
+            }
+            if ( character == '\0' ) {
+                character = KeyEvent.CHAR_UNDEFINED;
+            }
+            if ( focusOwner != null ) {
+                if ( pressed ) {
+                    KeyEvent event = new KeyEvent( focusOwner, KeyEvent.KEY_PRESSED,
+                            System.currentTimeMillis(), getCurrentModifiers( -1 ),
+                            keyCode, character );
+                    dispatchEvent( focusOwner, event );
+                    anInt.value = keyCode;
+                    Char c = characters.get( anInt );
+                    if ( c == null ) {
+                        characters.put( new Int( keyCode ), new Char( character ) );
+                    }
+                    else {
+                        c.value = character;
+                    }
+                    if ( character != KeyEvent.CHAR_UNDEFINED ) {
+                        dispatchEvent( focusOwner, new KeyEvent( focusOwner, KeyEvent.KEY_TYPED,
+                                System.currentTimeMillis(), getCurrentModifiers( -1 ),
+                                0, character ) );
+                    }
+                }
+                if ( !pressed ) {
+                    anInt.value = keyCode;
+                    Char c = characters.get( anInt );
+                    if ( c != null ) {
+                        character = c.value;
+                        //TODO: repeat input
+//                        if ( character != KeyEvent.CHAR_UNDEFINED ) {
+//                            dispatchEvent( focusOwner, new KeyEvent( focusOwner, KeyEvent.KEY_TYPED,
+//                                    System.currentTimeMillis(), getCurrentModifiers( -1 ),
+//                                    0, character ) );
+//                        }
+                    }
+                    dispatchEvent( focusOwner, new KeyEvent( focusOwner, KeyEvent.KEY_RELEASED,
+                            System.currentTimeMillis(), getCurrentModifiers( -1 ),
+                            keyCode, character ) );
+                }
+            }
+        }
+    }
+
+    private void dispatchEvent( final Component receiver, final AWTEvent event ) {
+        if ( getModalComponent() == null || SwingUtilities.isDescendingFrom( receiver, getModalComponent() ) ) {
+            if ( !SwingUtilities.isEventDispatchThread() ) {
+                throw new IllegalStateException( "not in swing thread!" );
+            }
+            receiver.dispatchEvent( event );
+        }
+    }
+
+    private static Int anInt = new Int( 0 );
+
+    private static class Int {
+        public Int( int value ) {
+            this.value = value;
+        }
+
+        public boolean equals( Object obj ) {
+            return obj instanceof Int && ( (Int) obj ).value == value;
+
+        }
+
+        public int hashCode() {
+            return value;
+        }
+
+        int value;
+    }
+
+    private static class Char {
+        public Char( char value ) {
+            this.value = value;
+        }
+
+        char value;
+    }
+
+    /**
+     * From keyCode (Int) to character (Char)
+     */
+    private Map<Int,Char> characters = new HashMap<Int,Char>();
+
+    private static void dontDrawBackground( Container container ) {
+        if ( container != null ) {
+            container.setBackground( null );
+            if ( container instanceof JComponent ) {
+                final JComponent component = ( (JComponent) container );
+                component.setOpaque( false );
+            }
+            dontDrawBackground( container.getParent() );
+        }
+    }
+
+    private static int powerOf2SizeIfNeeded( int size, boolean generateMipMaps ) {
+        if ( generateMipMaps ) { // || !TextureState.isNonPowerOfTwoTextureSupported() ) {
+            int powerOf2Size = 1;
+            while ( powerOf2Size < size ) {
+                powerOf2Size <<= 1;
+            }
+            return powerOf2Size;
+        }
+        
+        return size;       
+    }
+
+    private Component lastComponent;
+    private Component grabbedMouse;
+    private int grabbedMouseButton;
+    private int downX = 0;
+    private int downY = 0;
+    private long lastClickTime = 0;
+    private int clickCount = 0;
+    private static final int MAX_CLICKED_OFFSET = 4;
+
+    private Vector2f location = new Vector2f();
+
+    private void sendAWTWheelEvent( int wheelDelta, int x, int y ) {
+        Component comp = lastComponent != null ? lastComponent : componentAt( x, y, desktop, false );
+        if ( comp == null ) {
+            comp = desktop;
+        }
+        final Point pos = convertPoint( desktop, x, y, comp );
+        final MouseWheelEvent event = new MouseWheelEvent( comp,
+                MouseEvent.MOUSE_WHEEL,
+                System.currentTimeMillis(), getCurrentModifiers( -1 ), pos.x, pos.y, 1, false,
+                MouseWheelEvent.WHEEL_UNIT_SCROLL,
+                Math.abs( wheelDelta ), wheelDelta > 0 ? -1 : 1 );
+        dispatchEvent( comp, event );
+    }
+
+    private boolean useConvertPoint = true;
+
+    private Point convertPoint( Component parent, int x, int y, Component comp ) {
+        if ( useConvertPoint ) {
+            try {
+                return SwingUtilities.convertPoint( parent, x, y, comp );
+            } catch ( InternalError e ) {
+                useConvertPoint = false;
+            }
+        }
+        if ( comp != null ) {
+            while ( comp != parent ) {
+                x -= comp.getX();
+                y -= comp.getY();
+                if ( comp.getParent() == null ) {
+                    break;
+                }
+                comp = comp.getParent();
+            }
+        }
+        return new Point( x, y );
+    }
+
+    private void sendAWTMouseEvent( int x, int y, boolean pressed, int swingButton ) {
+        Component comp = componentAt( x, y, desktop, false );
+
+        final int eventType;
+        if ( swingButton > MouseEvent.NOBUTTON ) {
+            eventType = pressed ? MouseEvent.MOUSE_PRESSED : MouseEvent.MOUSE_RELEASED;
+        }
+        else {
+            eventType = getButtonMask( MouseEvent.NOBUTTON ) == 0 ? MouseEvent.MOUSE_MOVED : MouseEvent.MOUSE_DRAGGED;
+        }
+
+        final long time = System.currentTimeMillis();
+        if ( lastComponent != comp ) {
+            //enter/leave events
+            while ( lastComponent != null && ( comp == null || !SwingUtilities.isDescendingFrom( comp, lastComponent ) ) )
+            {
+                final Point pos = convertPoint( desktop, x, y, lastComponent );
+                sendExitedEvent( lastComponent, getCurrentModifiers( swingButton ), pos );
+                lastComponent = lastComponent.getParent();
+            }
+            final Point pos = convertPoint( desktop, x, y, lastComponent );
+            if ( lastComponent == null ) {
+                lastComponent = desktop;
+            }
+            sendEnteredEvent( comp, lastComponent, getCurrentModifiers( swingButton ), pos );
+            lastComponent = comp;
+            downX = Integer.MIN_VALUE;
+            downY = Integer.MIN_VALUE;
+            lastClickTime = 0;
+        }
+
+        if ( comp != null ) {
+            boolean clicked = false;
+            if ( swingButton > MouseEvent.NOBUTTON ) {
+                if ( pressed ) {
+                    grabbedMouse = comp;
+                    grabbedMouseButton = swingButton;
+                    downX = x;
+                    downY = y;
+                    setFocusOwner( componentAt( x, y, desktop, true ) );
+                }
+                else if ( grabbedMouseButton == swingButton && grabbedMouse != null ) {
+                    comp = grabbedMouse;
+                    grabbedMouse = null;
+                    if ( Math.abs( downX - x ) <= MAX_CLICKED_OFFSET && Math.abs( downY - y ) < MAX_CLICKED_OFFSET ) {
+                        if ( lastClickTime + DOUBLE_CLICK_TIME > time ) {
+                            clickCount++;
+                        }
+                        else {
+                            clickCount = 1;
+                        }
+                        clicked = true;
+                        lastClickTime = time;
+                    }
+                    downX = Integer.MIN_VALUE;
+                    downY = Integer.MIN_VALUE;
+                }
+            }
+            else if ( grabbedMouse != null ) {
+                comp = grabbedMouse;
+            }
+
+            final Point pos = convertPoint( desktop, x, y, comp );
+            final MouseEvent event = new MouseEvent( comp,
+                    eventType,
+                    time, getCurrentModifiers( swingButton ), pos.x, pos.y, clickCount,
+                    swingButton == MouseEvent.BUTTON2 && pressed, // todo: should this be platform dependent? (e.g. mac)
+                    swingButton >= 0 ? swingButton : 0 );
+            dispatchEvent( comp, event );
+            if ( clicked ) {
+                // CLICKED seems to need special glass pane handling o_O
+                comp = componentAt( x, y, desktop, true );
+                final Point clickedPos = convertPoint( desktop, x, y, comp );
+
+                final MouseEvent clickedEvent = new MouseEvent( comp,
+                        MouseEvent.MOUSE_CLICKED,
+                        time, getCurrentModifiers( swingButton ), clickedPos.x, clickedPos.y, clickCount,
+                        false, swingButton );
+                dispatchEvent( comp, clickedEvent );
+            }
+        }
+        else if ( pressed ) {
+            // clicked no component at all
+            setFocusOwner( null );
+        }
+    }
+
+    private boolean focusCleared = false;
+
+    public void setFocusOwner( Component comp ) {
+        if ( comp == null || comp.isFocusable() ) {
+            for ( Component p = comp; p != null; p = p.getParent() ) {
+                if ( p instanceof JInternalFrame ) {
+                    try {
+                        ( (JInternalFrame) p ).setSelected( true );
+                    } catch ( PropertyVetoException e ) {
+                        logger.logp(Level.SEVERE, this.getClass().toString(),
+                                "setFocusOwner(Component comp)", "Exception", e);
+                    }
+                }
+            }
+            awtWindow.setFocusableWindowState( true );
+            Component oldFocusOwner = getFocusOwner();
+            if ( comp == desktop ) {
+                comp = null;
+            }
+            if ( oldFocusOwner != comp ) {
+                if ( oldFocusOwner != null ) {
+                    dispatchEvent( oldFocusOwner, new FocusEvent( oldFocusOwner,
+                            FocusEvent.FOCUS_LOST, false, comp ) );
+                }
+                KeyboardFocusManager.getCurrentKeyboardFocusManager().clearGlobalFocusOwner();
+                if ( comp != null ) {
+                    dispatchEvent( comp, new FocusEvent( comp,
+                            FocusEvent.FOCUS_GAINED, false, oldFocusOwner ) );
+                }
+            }
+            awtWindow.setFocusableWindowState( false );
+        }
+        focusCleared = comp == null;
+    }
+
+    private int getCurrentModifiers( int swingBtton ) {
+        int modifiers = 0;
+        if ( isKeyDown( KeyInput.KEY_LMENU ) ) {
+            modifiers |= InputEvent.ALT_DOWN_MASK;
+            modifiers |= InputEvent.ALT_MASK;
+        }
+        if ( isKeyDown( KeyInput.KEY_RMENU ) ) {
+            modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;
+            modifiers |= InputEvent.ALT_GRAPH_MASK;
+        }
+        if ( isKeyDown( KeyInput.KEY_LCONTROL ) || isKeyDown( KeyInput.KEY_RCONTROL ) ) {
+            modifiers |= InputEvent.CTRL_DOWN_MASK;
+            modifiers |= InputEvent.CTRL_MASK;
+        }
+        if ( isKeyDown( KeyInput.KEY_LSHIFT ) || isKeyDown( KeyInput.KEY_RSHIFT ) ) {
+            modifiers |= InputEvent.SHIFT_DOWN_MASK;
+            modifiers |= InputEvent.SHIFT_MASK;
+        }
+        return modifiers | getButtonMask( swingBtton );
+    }
+
+
+    boolean butLMenuDown = false;
+    boolean butRMenuDown = false;
+    boolean butLControlDown = false;
+    boolean butRControlDown = false;
+    boolean butLShiftDown = false;
+    boolean butRShiftDown = false;
+
+    private boolean isKeyDown( int key )
+    {
+      if (key==KeyInput.KEY_LMENU) {return butLMenuDown;}
+      else if (key==KeyInput.KEY_RMENU) {return butRMenuDown;}
+      else if (key==KeyInput.KEY_LCONTROL) {return butLControlDown;}
+      else if (key==KeyInput.KEY_RCONTROL) {return butRControlDown;}
+      else if (key==KeyInput.KEY_LSHIFT) {return butLShiftDown;}
+      else if (key==KeyInput.KEY_RSHIFT) {return butRShiftDown;}
+      System.err.println("JMEDesktop.java: Key not supported: "+key);
+      return false;
+    }
+
+    private void setKeyDown( int key, boolean down )
+    {
+      if (key==KeyInput.KEY_LMENU) {butLMenuDown = down;}
+      else if (key==KeyInput.KEY_RMENU) {butRMenuDown = down;}
+      else if (key==KeyInput.KEY_LCONTROL) {butLControlDown = down;}
+      else if (key==KeyInput.KEY_RCONTROL) {butRControlDown = down;}
+      else if (key==KeyInput.KEY_LSHIFT) {butLShiftDown = down;}
+      else if (key==KeyInput.KEY_RSHIFT) {butRShiftDown = down;}
+    }
+
+    boolean m1 = false;
+    boolean m2 = false;
+    boolean m3 = false;
+    private void setButtonDown( int mouseBut, boolean down)
+    {
+      if (mouseBut == 0) { m1 = down; }
+      if (mouseBut == 1) { m2 = down; }
+      if (mouseBut == 2) { m3 = down; }
+    }
+
+    private boolean isButtonDown( int mouseBut )
+    {
+      if (mouseBut == 0) { return m1; }
+      if (mouseBut == 1) { return m2; }
+      if (mouseBut == 2) { return m3; }
+      System.err.println("JMEDesktop.java: Button not supported: "+mouseBut);
+      return false;
+    }
+
+    private int getButtonMask( int swingButton ) {
+        int buttonMask = 0;
+        if ( isButtonDown( 0 ) || swingButton == MouseEvent.BUTTON1 ) {
+            buttonMask |= InputEvent.BUTTON1_MASK;
+            buttonMask |= InputEvent.BUTTON1_DOWN_MASK;
+        }
+        if ( isButtonDown( 1 ) || swingButton == MouseEvent.BUTTON2 ) {
+            buttonMask |= InputEvent.BUTTON2_MASK;
+            buttonMask |= InputEvent.BUTTON2_DOWN_MASK;
+        }
+        if ( isButtonDown( 2 ) || swingButton == MouseEvent.BUTTON3 ) {
+            buttonMask |= InputEvent.BUTTON3_MASK;
+            buttonMask |= InputEvent.BUTTON3_DOWN_MASK;
+        }
+        return buttonMask;
+    }
+
+    private int convertButton(int mouseBut)
+    {
+      if (mouseBut == 0) { return MouseEvent.BUTTON1; }
+      if (mouseBut == 1) { return MouseEvent.BUTTON2; }
+      if (mouseBut == 2) { return MouseEvent.BUTTON3; }
+      System.err.println("JMEDesktop.java - convertButton(): Button not supported: "+mouseBut);
+      return mouseBut;
+    }
+
+    private int lastXin = -1;
+    private int lastXout = -1;
+    private int lastYin = -1;
+    private int lastYout = -1;
+
+    private Ray pickRay = new Ray();
+    private Vector3f bottomLeft = new Vector3f();
+    private Vector3f topLeft = new Vector3f();
+    private Vector3f topRight = new Vector3f();
+    private Vector3f bottomRight = new Vector3f();
+    private Vector3f tuv = new Vector3f();
+
+    /**
+     * Convert mouse coordinates from jME screen to JMEDesktop coordinates (Swing).
+     * @param x jME x coordinate
+     * @param y jME y coordinate
+     * @param store resulting JDesktop coordinates
+     */
+    public void convert( int x, int y, Vector2f store ) {
+        if ( lastXin == x && lastYin == y ) {
+            store.x = lastXout;
+            store.y = lastYout;
+        }
+        else {
+            lastXin = x;
+            lastYin = y;
+logger.fine("Warning in JMEDesktop.java: Gehe von QUEUE_ORTHO aus! (assume QUEUE_ORTHO)");
+//            if ( getRenderQueueMode() == Renderer.QUEUE_ORTHO ) {
+                //TODO: occlusion by other quads (JMEFrames)
+x = (int) (x * (desktopWidth/(desktopWidth*getLocalScale().x)));
+y = (int) (desktopHeight - (y * (desktopHeight/(desktopHeight*getLocalScale().y))));
+//                x = (int) ( x - getWorldTranslation().x  );
+//                y = (int) (  ( (desktopHeight-y) - getWorldTranslation().y ) );
+//            }
+/*
+            else {
+                store.set( x, y );
+                DisplaySystem.getDisplaySystem().getWorldCoordinates( store, 0, pickRay.origin );
+                DisplaySystem.getDisplaySystem().getWorldCoordinates( store, 0.3f, pickRay.direction ).subtractLocal( pickRay.origin ).normalizeLocal();
+
+                applyWorld( bottomLeft.set( -width * 0.5f, -height * 0.5f, 0 ) );
+                applyWorld( topLeft.set( -width * 0.5f, height * 0.5f, 0 ) );
+                applyWorld( topRight.set( width * 0.5f, height * 0.5f, 0 ) );
+                applyWorld( bottomRight.set( width * 0.5f, -height * 0.5f, 0 ) );
+
+                if ( pickRay.intersectWherePlanarQuad( topLeft, topRight, bottomLeft, tuv ) ) {
+                    x = (int) ( ( tuv.y - 0.5f ) * width ) + desktopWidth / 2;
+                    y = (int) ( ( tuv.z - 0.5f ) * height ) + desktopHeight / 2;
+                }
+                else {
+                    x = -1;
+                    y = -1;
+                }
+            }
+*/
+            lastYout = y;
+            lastXout = x;
+
+            store.set( x, y );
+        }
+    }
+
+    private void applyWorld( Vector3f point ) {
+        getWorldRotation().multLocal( point.multLocal( getWorldScale() ) ).addLocal( getWorldTranslation() );
+    }
+
+    /**
+     * Find a component at specified desktop position.
+     *
+     * @param x x coordinate in Swing coordinate space
+     * @param y y coordinate in Swing coordinate space
+     * @return the top most component at specified location, null if no child component is found at that location
+     */
+    public Component componentAt( int x, int y ) {
+        Component component = componentAt( x, y, desktop, true );
+        if ( component != desktop ) {
+            return component;
+        }
+       
+        return null;        
+    }
+
+    private Component componentAt( int x, int y, Component parent, boolean scanRootPanes ) {
+        if ( scanRootPanes && parent instanceof JRootPane ) {
+            JRootPane rootPane = (JRootPane) parent;
+            parent = rootPane.getContentPane();
+        }
+
+        Component child = parent;
+        if ( !parent.contains( x, y ) ) {
+            child = null;
+        }
+        else {
+            synchronized ( parent.getTreeLock() ) {
+                if ( parent instanceof Container ) {
+                    Container container = (Container) parent;
+                    int ncomponents = container.getComponentCount();
+                    for ( int i = 0; i < ncomponents; i++ ) {
+                        Component comp = container.getComponent( i );
+                        if ( comp != null
+                                && comp.isVisible()
+                                && ( dragAndDropSupport == null || !dragAndDropSupport.isDragPanel(comp) )
+                                && comp.contains( x - comp.getX(), y - comp.getY() ) ) {
+                            child = comp;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        if ( child != null ) {
+            if ( parent instanceof JTabbedPane && child != parent ) {
+                child = ( (JTabbedPane) parent ).getSelectedComponent();
+            }
+            x -= child.getX();
+            y -= child.getY();
+        }
+        return child != parent && child != null ? componentAt( x, y, child, scanRootPanes ) : child;
+    }
+
+    private void sendEnteredEvent( Component comp, Component lastComponent, int buttonMask, Point pos ) {
+        if ( comp != null && comp != lastComponent ) {
+            sendEnteredEvent( comp.getParent(), lastComponent, buttonMask, pos );
+
+            pos = convertPoint( lastComponent, pos.x, pos.y, comp );
+            final MouseEvent event = new MouseEvent( comp,
+                    MouseEvent.MOUSE_ENTERED,
+                    System.currentTimeMillis(), buttonMask, pos.x, pos.y, 0, false, 0 );
+            dispatchEvent( comp, event );
+        }
+
+    }
+
+    private void sendExitedEvent( Component lastComponent, int buttonMask, Point pos ) {
+        final MouseEvent event = new MouseEvent( lastComponent,
+                MouseEvent.MOUSE_EXITED,
+                System.currentTimeMillis(), buttonMask, pos.x, pos.y, 1, false, 0 );
+        dispatchEvent( lastComponent, event );
+    }
+
+    private final LockRunnable paintLockRunnable = new LockRunnable();
+
+    @Override
+    public void updateGeometricState() {
+        if ( graphics.isDirty() ) {
+            final boolean synchronizingThreadsOnUpdate = this.synchronizingThreadsOnUpdate;
+            if ( synchronizingThreadsOnUpdate ) {
+                synchronized ( paintLockRunnable ) {
+                    try {
+                        paintLockRunnable.wait = true;
+                        if (!disposing)SwingUtilities.invokeLater( paintLockRunnable );
+                        paintLockRunnable.wait( 100 );
+                    } catch ( InterruptedException e ) {
+                        logger.logp(Level.SEVERE, this.getClass().toString(), "draw(Renderer r)", "Exception", e);
+                    }
+                }
+            }
+            try {
+                if ( graphics != null ) { // && texture.getTextureId() > 0) {
+                    graphics.update( texture );
+                }
+            } finally {
+
+                if ( synchronizingThreadsOnUpdate ) {
+                    synchronized ( paintLockRunnable ) {
+                        paintLockRunnable.notifyAll();
+                    }
+                }
+            }
+        }
+texture.getImage().setUpdateNeeded();
+//getLocalTranslation().set(starcom.jme3d.Referenz.view.getLocation().add(starcom.jme3d.Referenz.view.getDirection()));
+//getLocalRotation().set(starcom.jme3d.Referenz.view.getRotation());
+        super.updateGeometricState();
+    }
+
+    public JDesktopPane getJDesktop() {
+        return desktop;
+    }
+
+    public Component getFocusOwner() {
+        if ( !focusCleared ) {
+            return this.awtWindow.getFocusOwner();
+        }
+       
+        return null;        
+    }
+
+    private class LockRunnable implements Runnable {
+        private boolean wait = false;
+
+        public void run() {
+            synchronized ( paintLockRunnable ) {
+                notifyAll();
+                if ( wait ) {
+                    try {
+                        //wait for repaint to finish
+                        wait = false;
+                        paintLockRunnable.wait( 200 );
+                    } catch ( InterruptedException e ) {
+                        logger.logp(Level.SEVERE, this.getClass().toString(),
+                                "run()", "Exception", e);
+                    }
+                }
+            }
+        }
+    }
+
+    private static class MyPopupFactory extends PopupFactory {
+        private final PopupFactory defaultPopupFactory = new PopupFactory();
+
+        public Popup getPopup( Component owner, Component contents, int x, int y ) throws IllegalArgumentException {
+            while ( !( owner instanceof JDesktopPane ) ) {
+                owner = owner.getParent();
+                if ( owner == null ) {
+                    logger.warning("jME Popup creation failed, default popup created - desktop not found in component hierarchy of "
+                                    + owner);
+                    return defaultPopupFactory.getPopup( owner, contents, x, y );
+                }
+            }
+            JMEDesktop.LightWeightPopup popup = new JMEDesktop.LightWeightPopup( (JComponent) owner );
+            popup.adjust( owner, contents, x, y );
+            return popup;
+        }
+    }
+
+    /**
+     * @return current modal component
+     * @see #setModalComponent(java.awt.Component)
+     */
+    public Component getModalComponent() {
+        return this.modalComponent;
+    }
+
+    /**
+     * @see #setModalComponent(java.awt.Component)
+     */
+    private Component modalComponent;
+
+    /**
+     * Filter the swing event to allow events to the specified component and its children only.
+     * Note: this does not prevent shortcuts and mnemonics to work for the other components!
+     *
+     * @param value component that can be exclusively accessed (including children)
+     */
+    public void setModalComponent( final Component value ) {
+        this.modalComponent = value;
+    }
+
+    protected void setParent( Node parent ) {
+        if ( desktop != null ) {
+            super.setParent( parent );
+        }
+        else {
+            throw new IllegalStateException( "already disposed" );
+        }
+    }
+
+ /**
+  * Call this method of the desktop is no longer needed. Removes this from the scenegraph, later use is not
+  * possible any more.
+  */
+  public void dispose()
+  {
+    disposing = true;
+    SwingUtilities.invokeLater( new Runnable()
+    {
+      public void run()
+      {
+        System.out.println("Disposing JMEDesktop: START");
+        doDispose();
+        System.out.println("Disposing JMEDesktop: READY");
+      }
+    } );
+  }
+
+  private void doDispose(){
+        if ( desktop != null ) {
+            if ( getParent() != null ) {
+                getParent().detachChild( this );
+            }
+            if ( rawInputListener != null ) {
+                inputManager.removeRawInputListener( rawInputListener );
+            }
+            desktop.removeAll();
+            awtWindow.dispose();
+            desktop = null;
+            desktopsUsed--;
+            if ( desktopsUsed == 0 ) {
+                PopupFactory.setSharedInstance( new PopupFactory() );
+            }
+        }
+    }
+
+    private static class ScrollPaneRepaintFixListener implements ContainerListener {
+        public void componentAdded( ContainerEvent e ) {
+            Component child = e.getChild();
+            componentAdded( child );
+        }
+
+        private void componentAdded( Component child ) {
+            if ( child instanceof Container ) {
+                Container container = (Container) child;
+                addTo( container );
+                container.addContainerListener( this );
+            }
+            if ( child instanceof JScrollPane ) {
+                final JScrollPane scrollPane = (JScrollPane) child;
+                // note: the listener added here is only a fix for repaint problems with scrolling
+                subscribeRepaintListener( scrollPane.getViewport() );
+            }
+        }
+
+        private void addTo( Container container ) {
+            container.addContainerListener( this );
+            for ( int i = 0; i < container.getComponentCount(); i++ ) {
+                componentAdded( container.getComponent( i ) );
+            }
+        }
+
+        private void removeFrom( Container container ) {
+            container.removeContainerListener( this );
+            for ( int i = 0; i < container.getComponentCount(); i++ ) {
+                componentRemoved( container.getComponent( i ) );
+            }
+        }
+
+        private void subscribeRepaintListener( JViewport viewport ) {
+            for ( int i = 0; i < viewport.getChangeListeners().length; i++ ) {
+                ChangeListener listener = viewport.getChangeListeners()[i];
+                if ( listener instanceof ScrollPaneRepaintChangeListener ) {
+                    // listener already subscribed
+                    return;
+                }
+            }
+            viewport.addChangeListener( new ScrollPaneRepaintChangeListener( viewport ) );
+        }
+
+        public void componentRemoved( ContainerEvent e ) {
+            Component child = e.getChild();
+            componentRemoved( child );
+        }
+
+        private void componentRemoved( Component child ) {
+            if ( child instanceof Container ) {
+                Container container = (Container) child;
+                removeFrom( container );
+            }
+        }
+
+        private static class ScrollPaneRepaintChangeListener implements ChangeListener {
+            private final Component component;
+
+            public ScrollPaneRepaintChangeListener( Component component ) {
+                this.component = component;
+            }
+
+            public void stateChanged( ChangeEvent e ) {
+                component.repaint();
+            }
+        }
+    }
+
+}
Index: src/swingGui/com/jme3/swingGui/component/ComboBox.java
===================================================================
--- src/swingGui/com/jme3/swingGui/component/ComboBox.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/component/ComboBox.java	(revision 0)
@@ -0,0 +1,155 @@
+package com.jme3.swingGui.component;
+
+import java.io.*;
+import java.applet.*;
+import java.net.*;
+import java.util.*;
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.image.*;
+import javax.swing.*;
+import javax.swing.event.*;
+import com.jme3.swingGui.JMEDesktop;
+
+public class ComboBox extends JButton implements ActionListener
+{
+  ArrayList<Object> items = new ArrayList<Object>();
+  ArrayList<ItemListener> iListeners = new ArrayList<ItemListener>();
+  Object selectedItem;
+ /**
+ * This class creates a Component similar to JComboBox.
+ * Its useful by problems with JComboBox (Popupmenu closes automatically)
+ * @author by user starcom "Paul Kashofer Austria"
+ */
+  public ComboBox()
+  {
+    super("empty");
+    addActionListener(this);
+    String dir = this.getClass().getResource("").getPath()+"cb.png";
+    ImageIcon pfeil = new ImageIcon(dir);
+    if (pfeil!=null)
+    {
+      setHorizontalTextPosition(JButton.LEFT);
+      setIcon(pfeil);
+    }
+  }
+
+  public Dimension getPreferredSize()
+  { // Dont hide the slider.
+    Dimension ret = super.getPreferredSize();
+    ret.setSize(ret.getWidth(),30);
+    return ret;
+  }
+
+  public void addItem(Object obj)
+  {
+    items.add(obj);
+    if (selectedItem==null) {setSelectedIndex(0);}
+  }
+  public void addItemListener(ItemListener i) {iListeners.add(i);}
+  public void actionPerformed(ActionEvent e)
+  {
+    createMenu();
+  }
+  public Object getSelectedItem() {return selectedItem;}
+  public int getSelectedIndex() {return getIndex(selectedItem);}
+  public int getIndex(Object obj)
+  {
+    for (int i=0; i<items.size(); i++)
+    {
+      if (items.get(i).equals(obj)) {return i;}
+    }
+    return -1;
+  }
+  public void setSelectedItem(Object obj)
+  {
+    setSelectedIndex(getIndex(obj));
+  }
+  public void setSelectedIndex(int i)
+  {
+    Object last = selectedItem;
+    if (items.get(i)==last) {return;}
+    setText(""+items.get(i));
+    selectedItem = items.get(i);
+    fireItemStateChanged(last,selectedItem);
+  }
+
+  void fireItemStateChanged(Object deselect, Object select)
+  {
+    if (deselect!=null)
+    {
+      ItemEvent e = new ItemEvent(new JButton(),0,deselect,ItemEvent.DESELECTED);
+      for (int i=0; i<iListeners.size(); i++) {iListeners.get(i).itemStateChanged(e);}
+    }
+    if (select!=null)
+    {
+      ItemEvent e = new ItemEvent(new JButton(),0,select,ItemEvent.SELECTED);
+      for (int i=0; i<iListeners.size(); i++) {iListeners.get(i).itemStateChanged(e);}
+    }
+  }
+
+  void createMenu()
+  {
+    PopMenu tmp = new PopMenu(getLocationOnScreen())
+    {
+      public void selected(int index)
+      {
+        setSelectedIndex(index);
+      }
+    };
+    for (int i=0; i<items.size(); i++)
+    {
+      if (items.get(i)==selectedItem) {tmp.addMenuItem(""+items.get(i),true);}
+      else {tmp.addMenuItem(""+items.get(i),false);}
+    }
+//    starcom.jme3d.Referenz.window.add(tmp); // Insert tmp-Frame into JMEDesktop
+  }
+
+  abstract class PopMenu extends JInternalFrame implements ActionListener
+  {
+    int index = 0;
+    JPanel main = new JPanel();
+    double prefSize = 0;
+    public PopMenu(Point loc) {super(); initNow(loc);}
+
+    void initNow(Point loc)
+    {
+      this.setLocation(loc);
+      main.setLayout(new GridLayout(0,1));
+      add(new JScrollPane(main));
+      setVisible(true);
+      addMouseListener(new MouseAdapter()
+      {
+        @Override
+        public void mouseExited(MouseEvent e)
+        {
+          setVisible(false);
+          dispose();
+        }
+      });
+    }
+
+    public void addMenuItem(String txt, boolean selected)
+    {
+      JButton tmp = new JButton(txt);
+      tmp.setActionCommand(""+index);
+      tmp.addActionListener(this);
+      if (selected) {tmp.setBackground(Color.BLUE.brighter());}
+      int thisSize = (int)tmp.getPreferredSize().getWidth();
+      if (thisSize>prefSize)
+      {
+        prefSize=thisSize;
+        setSize((int)prefSize+30,300);
+      }
+      main.add(tmp);
+      index++;
+    }
+    public void actionPerformed(ActionEvent e)
+    {
+      selected(Integer.parseInt(e.getActionCommand()));
+      setVisible(false);
+      dispose();
+    }
+    public abstract void selected(int index);
+  }
+}
\ No newline at end of file
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDndException.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDndException.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDndException.java	(revision 0)
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+/**
+ * @author Galun
+ */
+public class JMEDndException extends Exception {
+
+    private static final long serialVersionUID = -398658764587033142L;
+
+    public JMEDndException( String msg ) {
+        super( msg );
+    }
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDragAndDrop.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDragAndDrop.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDragAndDrop.java	(revision 0)
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.Container;
+import java.awt.Dimension;
+import java.awt.Font;
+import java.awt.Graphics;
+import java.awt.Point;
+import java.awt.datatransfer.Transferable;
+import java.awt.event.MouseEvent;
+import java.awt.image.BufferedImage;
+import java.util.logging.Logger;
+
+import javax.swing.ImageIcon;
+import javax.swing.JComponent;
+import javax.swing.JDesktopPane;
+import javax.swing.JLabel;
+import javax.swing.SwingUtilities;
+
+import com.jme3.swingGui.JMEDesktop;
+
+/**
+ * Drag and Drop support for {@link JMEDesktop} see {@link jmetest.awt.swingui.dnd.TestJMEDragAndDrop} for an example.
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class JMEDragAndDrop {
+    private static final Logger logger = Logger.getLogger(JMEDragAndDrop.class
+            .getName());
+
+    private JMEDragGestureEvent dge;
+    private Transferable transferable;
+    private JMEDragSourceListener dragSourceListener;
+    private JMEDropTargetListener dropTargetListener;
+    private boolean dndInProgress;
+    private JMEDesktop desktop;
+    private boolean allowFreeDrop;
+    private JComponent dragComponent;
+
+    /**
+     * create a drag and drop support for this desktop
+     * @param desktop the JMEDesktop to add drag and drop support
+     */
+    public JMEDragAndDrop( JMEDesktop desktop ) {
+        dndInProgress = false;
+        setDesktop( desktop );
+    }
+
+    private void setDesktop( JMEDesktop desktop ) {
+        desktop.setDragAndDropSupport( this );
+        this.desktop = desktop;
+    }
+
+    /**
+     * get the transferable (the wrapped object to transport via drag and drop)
+     * @return the Transferable or null if there is no drag and drop in progress
+     */
+    public Transferable getTransferable() {
+        return transferable;
+    }
+
+    /**
+     * check if the component is the drag component
+     * @param c the component to check
+     * @return true if this is the drag component
+     */
+    public boolean isDragPanel( Component c ) {
+        return c != null && c == dragComponent;
+    }
+
+    /**
+     * start to drag an object
+     * this is the same as calling startDrag( JMEDragGestureEvent dge, ImageIcon icon, Transferable transferable,
+     * JMEDragSourceListener listener, false )
+     * 
+     * @param dge the drag gesture event that initiated the dragging
+     * @param icon the icon to represent the dragged object
+     * @param transferable the wrapped object to drag
+     * @param listener the drag source listener
+     * @throws JMEDndException
+     * @see #startDrag(JMEDragGestureEvent, javax.swing.ImageIcon, java.awt.datatransfer.Transferable, 
+     *                 JMEDragSourceListener, boolean)
+     */
+    public void startDrag(JMEDragGestureEvent dge, ImageIcon icon, Transferable transferable,
+                          JMEDragSourceListener listener) throws JMEDndException {
+        startDrag(dge, icon, transferable, listener, false);
+    }
+
+    /**
+     * start to drag an object
+     * @param dge the drag gesture event that initiated the dragging
+     * @param icon the icon to represent the dragged object
+     * @param transferable the wrapped object to drag
+     * @param listener the drag source listener
+     * @param allowFreeDrop whether to allow drops on the desktop without a drop target (drops in free space)
+     * @throws JMEDndException
+     */
+    public void startDrag( JMEDragGestureEvent dge, ImageIcon icon, Transferable transferable,
+                           JMEDragSourceListener listener, boolean allowFreeDrop ) throws JMEDndException {
+        if ( dndInProgress ) {
+            throw new JMEDndException( "drag and drop in progress" );
+        }
+        this.dge = dge;
+        this.transferable = transferable;
+        this.allowFreeDrop = allowFreeDrop;
+        dragSourceListener = listener;
+        // if drag source is also a drop target, initialize dropTargetListener to the same component
+        if (listener instanceof JMEDropTargetListener)
+            dropTargetListener = (JMEDropTargetListener)listener;
+        JLabel label = new JLabel( icon );
+        label.setName( "dragLabel" );
+        label.setSize( new Dimension( icon.getIconWidth(), icon.getIconHeight() ) );
+        dragComponent = label;
+        desktop.getJDesktop().add( dragComponent, Integer.MAX_VALUE );
+        desktop.getJDesktop().setComponentZOrder( dragComponent, 0 );
+        dndInProgress = true;
+    }
+
+    /**
+     * check whether there is currently a drag in progress
+     * @return true if there is a drag started
+     */
+    public boolean isDragging() {
+        return dndInProgress;
+    }
+
+    /**
+     * drag the icon around. This is called by the DragGestureRecognizer on Mouse Drag events
+     * @param event the mouse event
+     */
+    public void doDrag( MouseEvent event ) {
+        Point p = SwingUtilities.convertPoint((Component)event.getSource(), event.getX(), event.getY(), desktop.getJDesktop());
+        dragComponent.setLocation(p.x - dragComponent.getWidth() / 2, p.y - dragComponent.getHeight() / 2);
+        if (dropTargetListener != null) {
+            Point p2 = SwingUtilities.convertPoint(desktop.getJDesktop(), p.x, p.y, (Component)dropTargetListener);
+			dropTargetListener.dragOver(new JMEDropTargetEvent(event.getSource(),p2, dge.getAction(), this));
+        }
+    }
+
+    private JMEDropTargetListener getDropTargetListener(Container cont) {
+        for (int i = 0; i < cont.getComponentCount(); i++) {
+            Component c = cont.getComponent(i);
+            if (c instanceof JMEDropTargetListener)
+                return (JMEDropTargetListener)c;
+            if (c instanceof Container) {
+                JMEDropTargetListener dtl = getDropTargetListener((Container)c);
+                if (dtl != null)
+                    return dtl;
+            }
+        }
+        return null;
+    }
+
+    private JMEDropTargetListener getDropTargetListenerAt(Component c, int x, int y) {
+        Component cc = c.getComponentAt(x, y);
+        if (cc == null || cc == c)
+            return null;
+        if (cc instanceof JMEDropTargetListener)
+            return (JMEDropTargetListener)cc;        
+        if (cc instanceof Container)
+            return getDropTargetListener((Container)cc);
+        return null;
+    }
+
+    /**
+     * the drag is about to end. This is called by DragGestureRecongnizer after dragging when the mouse button
+     * is released
+     * @param e the mouse event that ends the dragging
+     */
+    public void doDrop(MouseEvent e) {
+        Point tp = e.getPoint();
+        //log.info("dropTargetListener=" + dropTargetListener + ", e=" + e);
+        dragComponent.setVisible(false);
+        desktop.getJDesktop().remove(dragComponent);
+        // check if we got confused by MOUSE_EXITED events
+        if (dropTargetListener == null && ! ((Component)dragSourceListener).contains(tp)) {
+            tp = SwingUtilities.convertPoint((Component)dragSourceListener, e.getX(), e.getY(), desktop.getJDesktop());
+            //log.info("looking at " + tp);
+            dropTargetListener = getDropTargetListenerAt(desktop.getJDesktop(), tp.x, tp.y);
+            //log.info("after restore: dropTargetListener:" + dropTargetListener);
+        }
+        boolean freeDrop = false;
+        boolean dropSuccess = false;
+        if (dropTargetListener != null) {
+            Point p = SwingUtilities.convertPoint((Component)dragSourceListener, e.getX(), e.getY(), (Component)dropTargetListener);
+			JMEDropTargetEvent dte = new JMEDropTargetEvent(e.getSource(),p, dge.getAction(), this);
+            dropTargetListener.drop(dte);
+            dropSuccess = dte.isCompleted();
+        } else {
+            if (allowFreeDrop) {
+                tp = SwingUtilities.convertPoint((Component)dragSourceListener, e.getX(), e.getY(), desktop.getJDesktop());
+                Component c = desktop.getJDesktop().getComponentAt(tp);
+                if (c == null || c instanceof JDesktopPane) {
+                    dropSuccess = true;
+                    freeDrop = true;
+                } else {
+                    logger.info("no drop target and dropped on " + tp + c);
+                }
+            } else
+                logger.info("no drop target and freedrop is not allowed.");
+        }
+        dragSourceListener.dragDropEnd(new JMEDragSourceEvent(tp, dge.getAction(), dropSuccess, freeDrop));
+        dndInProgress = false;
+        dropTargetListener = null;
+    }
+
+    /**
+     * called by the DragGestureRecognizer on mouse enter events
+     * @param e the mouse event that triggered
+     */
+    public void mouseEntered( MouseEvent e ) {
+        if ( e.getSource() instanceof JMEDropTargetListener ) {
+            dropTargetListener = (JMEDropTargetListener) e.getSource();
+            Point p = SwingUtilities.convertPoint((Component)dragSourceListener, e.getX(), e.getY(), (Component)dropTargetListener);
+			( (JMEDropTargetListener)e.getSource() ).dragEnter( new JMEDropTargetEvent(e.getSource(),p, dge.getAction(), this ) );
+        }
+        dragSourceListener.dragEnter( new JMEDragSourceEvent( e.getPoint(), dge.getAction(), e.getComponent() ) );
+    }
+
+    /**
+     * called by the DragGestureRecognizer on mouse exit events
+     * @param e the mouse event that triggered
+     */
+    public void mouseExited( MouseEvent e ) {
+        if ( e.getSource() instanceof JMEDropTargetListener ) {
+            dropTargetListener = null;
+            ( (JMEDropTargetListener) e.getSource() ).dragExit( new JMEDropTargetEvent(e.getSource(), e.getPoint(), dge.getAction(), this ) );
+        }
+        dragSourceListener.dragExit( new JMEDragSourceEvent( e.getPoint(), dge.getAction() ) );
+    }
+
+    /**
+     * creates an ImageIcon using the supplied text. This can be used to drag text around.
+     * @param c the component to take the font from (typically the drag source)
+     * @param text the text to put into the image
+     * @return a new ImageIcon
+     */
+    public static ImageIcon createTextIcon( JComponent c, String text ) {
+        Font font = c.getFont();
+        int mx = 2;
+        int my = 1;
+        int w = c.getFontMetrics( font ).stringWidth( text ) + mx * 2;
+        int h = c.getFontMetrics( font ).getHeight() + my * 2;
+        BufferedImage bi = new BufferedImage( w, h, BufferedImage.TYPE_4BYTE_ABGR );
+        Graphics g = bi.getGraphics();
+        g.setColor( Color.black );
+        g.fillRect( 0, 0, w, h );
+        g.setFont( font );
+        g.setColor( Color.yellow );
+        g.drawString( text, mx, h - my );
+        logger.info("created a text image for " + text + ": " + bi.toString());
+// try {
+//            ImageIO.write(bi, "png", new File("/tmp/text.png"));
+//        } catch (Exception ex) {}
+        return new ImageIcon( bi );
+    }
+
+    /**
+     * return the current drop target listener
+     * @return the current drop target listener or null if there is none
+     */
+    public JMEDropTargetListener getDropTargetListener() {
+        return dropTargetListener;
+    }
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureEvent.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureEvent.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureEvent.java	(revision 0)
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+import java.awt.Point;
+import java.awt.event.MouseEvent;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class JMEDragGestureEvent {
+
+    private JMEMouseDragGestureRecognizer recognizer;
+    private int action;
+    private Point point;
+    private MouseEvent event;
+
+    public JMEDragGestureEvent( JMEMouseDragGestureRecognizer recognizer, int action, Point point, MouseEvent event ) {
+        this.recognizer = recognizer;
+        this.action = action;
+        this.point = point;
+        this.event = event;
+    }
+
+    public JMEMouseDragGestureRecognizer getRecognizer() {
+        return recognizer;
+    }
+
+    public int getAction() {
+        return action;
+    }
+
+    public MouseEvent getEvent() {
+        return event;
+    }
+
+    public Point getPoint() {
+        return point;
+    }
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureListener.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureListener.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDragGestureListener.java	(revision 0)
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+/**
+ * @author Galun
+ */
+public interface JMEDragGestureListener {
+
+    void dragGestureRecognized( JMEDragGestureEvent dge );
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceEvent.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceEvent.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceEvent.java	(revision 0)
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+import java.awt.Component;
+import java.awt.Point;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class JMEDragSourceEvent {
+
+    private Point point;
+    private int action;
+    private boolean dropSuccess;
+    private boolean freeDrop;
+    private Component target;
+
+    /**
+     * a class to capsule drag events delivered to the drag source
+     * @param point the point the event occured
+     * @param action the action (see DndConstants in swing)
+     */
+    public JMEDragSourceEvent(Point point, int action) {
+        this(point, action, false, false);
+    }
+
+    /**
+     * a class to capsule drag events delivered to the drag source
+     * @param point the point the event occured
+     * @param action the action (see DndConstants in swing)
+     * @param success flag a successful dnd event
+     */
+    public JMEDragSourceEvent(Point point, int action, boolean success) {
+        this(point, action, success, false);
+    }
+
+    /**
+     * a class to capsule drag events delivered to the drag source
+     * @param point the point the event occured
+     * @param action the action (see DndConstants in swing)
+     * @param target the target component this event occured
+     */
+    public JMEDragSourceEvent(Point point, int action, Component target) {
+        this(point, action, false, false);
+        this.target = target;
+    }
+
+    /**
+     * a class to capsule drag events delivered to the drag source
+     * @param point the point the event occured
+     * @param action the action (see DndConstants in swing)
+     * @param success flag a successful dnd event
+     * @param freeDrop flag a drop outside of drop targets
+     */
+    public JMEDragSourceEvent(Point point, int action, boolean success, boolean freeDrop) {
+        this.point = point;
+        this.action = action;
+        this.dropSuccess = success;
+        this.freeDrop = freeDrop;
+        this.target = null;
+    }
+
+    public Point getPoint() {
+        return point;
+    }
+
+    public int getAction() {
+        return action;
+    }
+
+    protected void setDropSuccess(boolean success) {
+        dropSuccess = success;
+    }
+
+    public boolean getDropSuccess() {
+        return dropSuccess;
+    }
+
+    /**
+     * check if this is a drop outside of a drop target
+     * @return true if the a drop was outside of a drop target
+     */
+    public boolean isFreeDrop() {
+        return freeDrop;
+    }
+
+    /**
+     * set the free drop flag
+     * @param freeDrop TODO
+     */
+    public void setFreeDrop(boolean freeDrop) {
+        this.freeDrop = freeDrop;
+    }
+
+    public String toString() {
+        return "JMEDragSourceEvent[point=" + point.x + "/" + point.y + ", action=" + action +
+        ", dropSuccess=" + dropSuccess + ", freeDrop=" + freeDrop + ", target=" + target + "]";
+    }
+
+    /**
+     * @return the target component the drop occured
+     */
+    public Component getTarget() {
+        return target;
+    }
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceListener.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceListener.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDragSourceListener.java	(revision 0)
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public interface JMEDragSourceListener {
+
+    /**
+     * a transferable is dragged and enters the geometry of an object
+     *
+     * @param e the event describing what happened
+     */
+    void dragEnter( JMEDragSourceEvent e );
+
+    /**
+     * a transferable is dragged and leaves the geometry of an object
+     *
+     * @param e the event describing what happened
+     */
+    void dragExit( JMEDragSourceEvent e );
+
+    /**
+     * a drag operation ends
+     *
+     * @param e the event describing what happened
+     */
+    void dragDropEnd(JMEDragSourceEvent e);
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetEvent.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetEvent.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetEvent.java	(revision 0)
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+import java.awt.Point;
+import java.awt.datatransfer.Transferable;
+import java.util.EventObject;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class JMEDropTargetEvent extends EventObject {
+	
+	private static final long serialVersionUID = 1L;
+	private Point point;
+    private int action;
+    private boolean accepted;
+    private boolean completed;
+    private JMEDragAndDrop dnd;
+
+    
+     JMEDropTargetEvent(Object source, Point point, int action, JMEDragAndDrop dnd ) {
+        super(source);
+    	this.point = point;
+        this.action = action;
+        this.dnd = dnd;
+    }
+
+    public Point getPoint() {
+        return point;
+    }
+
+    public int getAction() {
+        return action;
+    }
+
+    public void acceptDrop( int action ) {
+        accepted = true;
+    }
+
+    public void dropComplete( boolean success ) {
+        completed = success;
+    }
+
+    public boolean isAccepted() {
+        return accepted;
+    }
+
+    public Transferable getTransferable() {
+        return dnd.getTransferable();
+    }
+
+    public boolean isCompleted() {
+        return completed;
+    }
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetListener.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetListener.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEDropTargetListener.java	(revision 0)
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public interface JMEDropTargetListener {
+
+    /**
+     * a transferable is dragged and enters the geometry of an object
+     *
+     * @param e the event describing what happened
+     */
+    void dragEnter( JMEDropTargetEvent e );
+
+    /**
+     * a transferable is dragged and leaves the geometry of an object
+     *
+     * @param e the event describing what happened
+     */
+    void dragExit( JMEDropTargetEvent e );
+
+    /**
+     * a transferable is dragged over the geometry of an object
+     * @param e the event describing what happened
+     */
+    void dragOver(JMEDropTargetEvent e);
+
+    /**
+     * a drag operation ends
+     *
+     * @param e the event describing what happened
+     */
+    void drop(JMEDropTargetEvent e);
+}
Index: src/swingGui/com/jme3/swingGui/dnd/JMEMouseDragGestureRecognizer.java
===================================================================
--- src/swingGui/com/jme3/swingGui/dnd/JMEMouseDragGestureRecognizer.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/dnd/JMEMouseDragGestureRecognizer.java	(revision 0)
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.dnd;
+
+import java.awt.Component;
+import java.awt.dnd.DnDConstants;
+import java.awt.event.InputEvent;
+import java.awt.event.MouseEvent;
+import java.awt.event.MouseListener;
+import java.awt.event.MouseMotionListener;
+
+import javax.swing.SwingUtilities;
+
+/**
+ * @author Galun
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class JMEMouseDragGestureRecognizer implements MouseListener, MouseMotionListener {
+
+    private MouseEvent firstEvent = null;
+    private int motionThreshold = 5;
+    //    private Logger log = logger;
+    private JMEDragGestureListener dragGestureListener;
+    private Component component;
+    private JMEDragAndDrop dnd;
+
+    /**
+     * create a new gesture recognizer that will send an event if it detects a drag gesture
+     *
+     * @param dragAndDropSupport JMEDragAndDrop this recognizer should use
+     * @param c   the component to monitor
+     * @param act the allowed action (TODO: not yet used - probably remove?) 
+     * @param dgl the drag gesture listener
+     */
+    public JMEMouseDragGestureRecognizer( JMEDragAndDrop dragAndDropSupport, Component c, int act, JMEDragGestureListener dgl ) {
+        dragGestureListener = dgl;
+        this.component = c;
+        c.addMouseListener( this );
+        c.addMouseMotionListener( this );
+        dnd = dragAndDropSupport;
+    }
+
+    protected int mapDragOperationFromModifiers( MouseEvent e ) {
+        int mods = e.getModifiersEx();
+
+        if ( ( mods & InputEvent.BUTTON1_DOWN_MASK ) != InputEvent.BUTTON1_DOWN_MASK ) {
+            return DnDConstants.ACTION_NONE;
+        }
+
+        return DnDConstants.ACTION_MOVE;
+    }
+
+    /**
+     * Invoked when the mouse has been pressed on a component.
+     * <p/>
+     *
+     * @param e the <code>MouseEvent</code>
+     */
+
+    public void mousePressed( MouseEvent e ) {
+//        TestJMEDragAndDrop.addText("mousePressed on " + ((JComponent)e.getSource()).getName());
+        if ( mapDragOperationFromModifiers( e ) != DnDConstants.ACTION_NONE ) {
+            firstEvent = e;
+            e.consume();
+        }
+    }
+
+    public void mouseReleased( MouseEvent e ) {
+        if ( dnd.isDragging() ) {
+            dnd.doDrop( e );
+        }
+        firstEvent = null;
+    }
+
+    public void mouseDragged( MouseEvent e ) {
+        //log.info("mouseDragged: " + e.getSource());
+//        TestJMEDragAndDrop.addText("mouseDragged: " + ((JComponent)e.getSource()).getName() +
+//                " " + e.getWhen() + " firstEvent" + (firstEvent == null ? "==" : "!=") + "null");
+        if ( firstEvent != null ) {
+            e.consume();
+
+            int action = mapDragOperationFromModifiers( e );
+            if ( action == DnDConstants.ACTION_NONE ) {
+                return;
+            }
+
+            int dx = Math.abs( e.getX() - firstEvent.getX() );
+            int dy = Math.abs( e.getY() - firstEvent.getY() );
+            if ( ( dx > getMotionThreshold() ) || ( dy > getMotionThreshold() ) ) {
+                SwingUtilities.convertMouseEvent( firstEvent.getComponent(), firstEvent, component );
+                final JMEDragGestureEvent dge = new JMEDragGestureEvent( this, action,
+                        firstEvent.getPoint(), firstEvent );
+                dispatchDragGestureEvent( dge );
+                firstEvent = null;
+            }
+        } else {
+            if ( dnd.isDragging() ) {
+                dnd.doDrag( e );
+                e.consume();
+            }
+        }
+    }
+
+    protected void dispatchDragGestureEvent( final JMEDragGestureEvent event ) {
+        SwingUtilities.invokeLater( new Runnable() {
+            public void run() {
+                dragGestureListener.dragGestureRecognized( event );
+            }
+        } );
+    }
+
+    /**
+     * get the minimum width in pixel (horiz. and vertical) that one has to drag before the event is fired
+     *
+     * @return the current threshold
+     */
+    public int getMotionThreshold() {
+        return motionThreshold;
+    }
+
+    /**
+     * set the minimum width in pixel (horiz. and vertical) that one has to drag before the event is fired
+     *
+     * @param newThreshold the width in pixel
+     */
+    public void setMotionThreshold( int newThreshold ) {
+        if ( newThreshold < 1 ) {
+            throw new IllegalArgumentException( "motion threshold must be at least 1" );
+        }
+        motionThreshold = newThreshold;
+    }
+
+    public void mouseClicked( MouseEvent e ) {
+        firstEvent = null;
+    }
+
+    public void mouseEntered( MouseEvent e ) {
+        if ( dnd.isDragging() ) {
+            dnd.mouseEntered( e );
+        }
+    }
+
+    public void mouseExited( MouseEvent e ) {
+        if ( dnd.isDragging() ) {
+            dnd.mouseExited( e );
+        }
+    }
+
+    public void mouseMoved(MouseEvent e) {
+    }
+}
Index: src/swingGui/com/jme3/swingGui/lwjgl/LWJGLImageGraphics.java
===================================================================
--- src/swingGui/com/jme3/swingGui/lwjgl/LWJGLImageGraphics.java	(revision 0)
+++ src/swingGui/com/jme3/swingGui/lwjgl/LWJGLImageGraphics.java	(revision 0)
@@ -0,0 +1,202 @@
+/*
+ * Copyright (c) 2003-2009 jMonkeyEngine
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ *
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ *
+ * * Neither the name of 'jMonkeyEngine' nor the names of its contributors
+ *   may be used to endorse or promote products derived from this software
+ *   without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+package com.jme3.swingGui.lwjgl;
+
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Rectangle;
+import java.awt.geom.Rectangle2D;
+import java.awt.image.BufferedImage;
+import java.nio.ByteBuffer;
+
+import org.lwjgl.opengl.GL11;
+import org.lwjgl.opengl.OpenGLException;
+import org.lwjgl.opengl.Util;
+import org.lwjgl.util.glu.GLU;
+
+import com.jme3.renderer.Renderer;
+import com.jme3.swingGui.ImageGraphics;
+import com.jme3.swingGui.ImageGraphicsBaseImpl;
+import com.jme3.texture.Texture;
+
+
+/**
+ * LWJGL implementation of {@link ImageGraphics}.
+ * @author Portet to jme3 by user starcom "Paul Kashofer Austria"
+ */
+public class LWJGLImageGraphics extends ImageGraphicsBaseImpl {
+
+    private Renderer renderer;
+    private GLU glu;
+
+    private LWJGLImageGraphics( BufferedImage awtImage, byte[] data, Graphics2D delegate,
+                                com.jme3.texture.Image image, Rectangle dirty,
+                                int translationX, int translationY,
+                                float scaleX, float scaleY, int mipMapCount,
+                                ImageGraphicsBaseImpl mipMapChild, int mipMapLevel ) {
+        super( awtImage, data, delegate, image, dirty, translationX, translationY, scaleX, scaleY,
+                mipMapCount, mipMapChild, mipMapLevel );
+    }
+
+    public LWJGLImageGraphics( int width, int height, int paintedMipMapCount , Renderer renderer) {
+        this( width, height, paintedMipMapCount, 0, 1, renderer );
+    }
+
+    private LWJGLImageGraphics( int width, int height, int paintedMipMapCount, int mipMapLevel, float scale, Renderer renderer ) {
+        super( width, height, paintedMipMapCount, mipMapLevel, scale );
+
+        this.renderer = renderer;
+        glu = new GLU();
+        if ( paintedMipMapCount > 0 && ( width > 1 || height > 1 ) ) {
+            if ( width < 2 ) {
+                width = 2;
+            }
+            if ( height < 2 ) {
+                height = 2;
+            }
+            mipMapChild = new LWJGLImageGraphics( width / 2, height / 2, paintedMipMapCount, mipMapLevel + 1, scale * 0.5f, renderer );
+        }
+    }
+
+    public void update( Texture texture, boolean clean ) {
+        boolean updateChildren = false;
+        synchronized ( dirty ) {
+            if (!tx.isIdentity()) {
+                dirty.setBounds(getImageBounds());
+            } else if ( !dirty.isEmpty() && isExpandDirtyRegion() ) {
+                dirty.grow( 2, 2 ); // to prevent antialiasing problems
+            }
+            Rectangle2D.intersect( dirty, getImageBounds(), dirty );
+
+            if ( !this.dirty.isEmpty() ) {
+
+                //debug: check if we already have an error from previous operations
+                try {
+                    Util.checkGLError();
+                } catch ( OpenGLException e ) {
+                    throw new RuntimeException("OpenGLException caused before any GL commands by LWJGLImageGraphics!", e );
+                }
+
+                boolean hasMipMaps = texture.getMinFilter().usesMipMapLevels();
+
+                update();
+                if ( !glTexSubImage2DSupported || ( hasMipMaps && paintedMipMapCount == 0 ) ) {
+
+                    if ( !hasMipMaps ) {
+//                        renderer.updateTextureSubImage(texture, 0, 0, image, 0,
+//                                        0, image.getWidth(), image.getHeight());
+                          texture.setImage(image);
+                    }
+                    else {
+                        // Remember what was previously bound.
+                        idBuff.clear();
+                        GL11.glGetInteger(GL11.GL_TEXTURE_BINDING_2D, idBuff);
+                        int oldTex = idBuff.get();
+
+                        GL11.glBindTexture( GL11.GL_TEXTURE_2D, 0 );
+                        //set alignment to support images with  width % 4 != 0, as images are not aligned
+                        GL11.glPixelStorei( GL11.GL_UNPACK_ALIGNMENT, 1 );
+
+                        ByteBuffer data = image.getData(0);
+                        data.rewind();
+                        
+                        glu.gluBuild2DMipmaps( GL11.GL_TEXTURE_2D,
+                                GL11.GL_RGBA8, image
+                                .getWidth(), image.getHeight(),
+                                GL11.GL_RGBA,
+                                GL11.GL_UNSIGNED_BYTE, data );
+                        
+                      // Rebind previous texture.
+                      GL11.glBindTexture(GL11.GL_TEXTURE_2D, oldTex);
+                    }
+                    //debug: check if texture operations caused an error
+                    Util.checkGLError();
+                }
+                else {
+//                    renderer.updateTextureSubImage(texture, dirty.x, dirty.y,
+//                                    image, dirty.x, dirty.y, dirty.width,
+//                                    dirty.height);
+                      texture.setImage(image);
+                    try {
+                        //debug: check if texture operations caused an error to print more info
+                        Util.checkGLError();
+                    } catch ( OpenGLException e ) {
+                        logger.warning("Error updating dirty region: " + dirty
+                                + " - "
+                                + "falling back to updating whole image!");
+                        glTexSubImage2DSupported = false;
+                        update( texture, clean );
+                    }
+                    updateChildren = mipMapChild != null;
+                }
+            }
+        }
+        if ( updateChildren ) {
+            // delete lowest order bit to make position dividable by two
+            dirty.x &= ~1;
+            dirty.y &= ~1;
+            // make size dividable by two
+            if ( ( dirty.width & 1 ) != 0 ) {
+                dirty.width++;
+            }
+            if ( ( dirty.height & 1 ) != 0 ) {
+                dirty.height++;
+            }
+
+            int dx1 = (int) ( ( dirty.x - translation.x ) / scaleX );
+            int dy1 = (int) ( ( dirty.y - translation.y ) / scaleY );
+            int dx2 = (int) ( ( dirty.x + dirty.width - translation.x ) / scaleX );
+            int dy2 = (int) ( ( dirty.y + dirty.height - translation.y ) / scaleY );
+            int dw = dx2 - dx1;
+            int dh = dy2 - dy1;
+            mipMapChild.setClip( dx1, dy1, dw, dh );
+            // draw image on the mip map child image but don't let them draw it on their children
+            mipMapChild.delegate.clearRect( dx1, dy1, dw, dh );
+            mipMapChild.delegate.drawImage( awtImage, dx1, dy1, dx2, dy2,
+                    dirty.x, dirty.y, dirty.x + dirty.width, dirty.y + dirty.height, null );
+            mipMapChild.makeDirty( dx1, dy1, dw, dh );
+
+            mipMapChild.update( texture, clean );
+        }
+        if ( clean ) {
+            this.dirty.width = 0;
+        }
+    }
+
+    public Graphics create() {
+        return new LWJGLImageGraphics( awtImage, data, (Graphics2D) delegate.create(), image, dirty,
+                translation.x, translation.y, scaleX, scaleY, paintedMipMapCount,
+                mipMapChild != null && mipMapLevel < paintedMipMapCount - 1
+                        ? (ImageGraphicsBaseImpl) mipMapChild.create() : null, mipMapLevel );
+    }
+}
